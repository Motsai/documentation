<!doctype html>
<html>
  <head>
    <meta charset="utf-8">
    <meta content="IE=edge,chrome=1" http-equiv="X-UA-Compatible">
    <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
    <title>API Documentation</title>

    <link href="stylesheets/screen.css" rel="stylesheet" type="text/css" media="screen" />
    <link href="stylesheets/print.css" rel="stylesheet" type="text/css" media="print" />
    <script src="https://ajax.googleapis.com/ajax/libs/jquery/2.1.3/jquery.min.js"></script>
      <script src="javascripts/all_nosearch.js" type="text/javascript"></script>


    <script type="text/javascript" src="http://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML">
    </script>
  </head>

  <body class="motionenginepackets">
    <a href="#" id="nav-button">
      <span>
        NAV
        <img src="images/navbar.png" />
      </span>
    </a>
    <div class="tocify-wrapper">
     <a href="http://www.motsai.com">
      <img src="images/logo.png" />
     </a>
      <div id="toc">
      </div>
    </div>
    <div class="page-wrapper">
      <div class="dark-box"></div>
      <div class="content">
        <h1 id="motion-engine-0x01">Motion Engine (0x01)</h1>

<p>The motion engine uses subsystem ID 0x01</p>

<p>Regarding the motion engine subsystem a number of commands exist, which are listed below:</p>
<pre class="highlight c"><code><span class="cp">#define Downsample 0x01 //Downsampling factor definition
#define MotionState 0x02 //streaming Motion State
#define IMU_Data 0x03 //streaming the 6-axis IMU data
#define Quaternion 0x04 //streaming the quaternion data
#define EulerAngle 0x05 //streaming the Euler angles
#define ExtForce 0x06 //streaming the external force
#define SetFusionType 0x07 //setting the Fusion type to either 6-axis or 9-axis
#define TrajectoryRecStartStop 0x08 //start/stop recording orientation trajectory
#define TrajectoryInfo 0x09 //Analyzes the current trajectory w.r.t. the pre-recorded one
#define Pedometer 0x0A //streaming pedometer data
#define MAG_Data 0x0B //streaming magnetometer data
#define SittingStanding 0x0C //sitting/standing tracker
#define LockHeadingRef 0x0D //locks the current magnetometer data to the reference 0 degrees heading angle
#define SetAccRange 0x0E //sets the accelerometer full-scale range
#define DisableAllStreaming 0x0F //disables all the streaming options in the motion engine
#define ResetTimeStamp  0x10 //resets the timestamp value to 0
#define FingerGesture   0x11 //detects finger swipe patterns, when Neblina is attached to a finger
#define RotationInfo    0x12 //streaming device rotation information: number of rotations, and speed in rpm
#define ExtrnHeadingCorrection 0x13 //external heading angle correction, e.g., from a camera, GPS, etc.
</span></code></pre>

<p>Note that the above commands are placed within the header section of the packet in Byte#3.</p>

<h2 id="data-section">Data Section</h2>

<p>The data section consists of 16 bytes. The first 4 bytes (Byte 4-7) refer to the timestamp, which is only valid for response packets from Neblina. Hence, for all the commands being sent from the host to Neblina, these four bytes are reserved. The next 12 bytes (Byte 8-19) in the data section could be representing different values depending on the subsystem and the command fields.</p>

<h3 id="motion-engine-data-section">Motion Engine Data Section</h3>

<p>The data section regarding the motion engine has different representations based on the command, which are explained next.</p>

<h4 id="downsample-command-0x01">Downsample Command (0x01)</h4>

<p>Neblina is programmed to stream information to the host as per its request. The maximum streaming frequency is 1kHz, and the users can reduce the streaming frequency to 1000/n, where n is an unsigned 16-bit positive integer. Regarding this command, we have the following data section with only 2 valid bytes:</p>

<h5 id="byte-8-n-lsb">Byte#8: n, LSB</h5>

<h5 id="byte-9-n-msb">Byte#9: n, MSB</h5>

<p>The representation is little-endian meaning that the least significant byte is put first, followed by higher order bytes, and finally ending with the most significant byte. Currently, the supporting streaming frequencies are multiplicands of 20, i.e., 50Hz, 50Hz/2, 50Hz/3, and so on. Therefore, the value of n should be set as a multiplicand of 20. Overall, the downsample command packet including both header and data sections has the following structure:</p>

<table><thead>
<tr>
<th style="text-align: center">Byte 0 (subsystem)</th>
<th style="text-align: center">Byte 1 (length)</th>
<th style="text-align: center">Byte 2 (CRC)</th>
<th style="text-align: center">Byte 3 (command)</th>
<th style="text-align: center">Byte 4-7</th>
<th style="text-align: center">Bytes 8-9</th>
<th style="text-align: center">Bytes 10-19</th>
</tr>
</thead><tbody>
<tr>
<td style="text-align: center">0x41</td>
<td style="text-align: center">0x10</td>
<td style="text-align: center">CRC</td>
<td style="text-align: center">0x01 (downsample)</td>
<td style="text-align: center">Reserved</td>
<td style="text-align: center">factor (n)</td>
<td style="text-align: center">Reserved</td>
</tr>
</tbody></table>

<p>In response, Neblina will only send an acknowledge/error packet to indicate the validity and receipt of the command issued by the host.</p>

<h4 id="motionstate-command-response-0x02">MotionState Command/Response (0x02)</h4>

<p>In the command mode the packet enables/disables the streaming of the motion state for the target device. If enabled, it basically inquires whether the device changes its motion state either from stop to movement, or from movement to stop. We recommend that after the device power-up you hold the device still for a couple of seconds (2-5 seconds) for initial calibration and orientation convergence. Data section for this packet type is a single byte, which should be set to either 0 or 1 to disable or enable the streaming of the motion states respectively.</p>

<h5 id="byte-8-enable-1-or-disable-0-motion-state-streaming">Byte#8: Enable (1) or Disable (0) Motion State streaming</h5>

<p>Overall, the command packet has the following structure:</p>

<table><thead>
<tr>
<th style="text-align: center">Byte 0 (subsystem)</th>
<th style="text-align: center">Byte 1 (length)</th>
<th style="text-align: center">Byte 2 (CRC)</th>
<th style="text-align: center">Byte 3 (command)</th>
<th style="text-align: center">Byte 4-7</th>
<th style="text-align: center">Byte 8</th>
<th>Bytes 9-19</th>
</tr>
</thead><tbody>
<tr>
<td style="text-align: center">0x41</td>
<td style="text-align: center">0x10</td>
<td style="text-align: center">CRC</td>
<td style="text-align: center">0x02 (motion state)</td>
<td style="text-align: center">Reserved</td>
<td style="text-align: center">Enable/Disable</td>
<td>Reserved</td>
</tr>
</tbody></table>

<p>In the response mode, Neblina will first send an acknowledge packet to the host to confirm the successful receipt of the command. Next, the main response packet will be prepared, where the data section first includes 4 bytes for the timestamp in microseconds (Byte#4-7) as a 32-bit unsigned integer value in little endian format. This means that Byte#4 is the LSB, and Byte#7 is the MSB of the timestamp. Next, we have the motion state data, i.e., a single byte (Byte#8), which is either 0 (stop motion) or 1 (start motion). The whole response packet structure including header is shown below:</p>

<table><thead>
<tr>
<th style="text-align: center">Byte 0 (subsystem)</th>
<th style="text-align: center">Byte 1 (length)</th>
<th style="text-align: center">Byte 2 (CRC)</th>
<th style="text-align: center">Byte 3 (command)</th>
<th style="text-align: center">Byte 4-7</th>
<th>Byte 8</th>
<th>Bytes 9-19</th>
</tr>
</thead><tbody>
<tr>
<td style="text-align: center">0x01</td>
<td style="text-align: center">0x10</td>
<td style="text-align: center">CRC</td>
<td style="text-align: center">0x02</td>
<td style="text-align: center">TimeStamp</td>
<td>stop/start</td>
<td>Reserved</td>
</tr>
</tbody></table>

<h4 id="imu_data-command-response-0x03">IMU_Data Command/Response (0x03)</h4>

<p>In the command mode, the packet enables/disables the streaming of the 6-axis IMU sensor data, including the 3-axis accelerometer and 3-axis gyroscope. Byte#8 will be a Boolean value representing the Enable/Disable command. The overall command mode IMU_Data packet has the following structure:</p>

<table><thead>
<tr>
<th style="text-align: center">Byte 0 (subsystem)</th>
<th style="text-align: center">Byte 1 (length)</th>
<th style="text-align: center">Byte 2 (CRC)</th>
<th style="text-align: center">Byte 3 (command)</th>
<th style="text-align: center">Byte 4-7</th>
<th style="text-align: center">Byte 8</th>
<th>Bytes 9-19</th>
</tr>
</thead><tbody>
<tr>
<td style="text-align: center">0x41</td>
<td style="text-align: center">0x10</td>
<td style="text-align: center">CRC</td>
<td style="text-align: center">0x03 (6-axis IMU)</td>
<td style="text-align: center">Reserved</td>
<td style="text-align: center">Enable/Disable</td>
<td>Reserved</td>
</tr>
</tbody></table>

<p>In the response mode, Neblina will first send an acknowledge packet to the host to confirm the successful receipt of the command. Next, the main response packet will be prepared, where the data section first includes 4 bytes for the timestamp (Byte#4-7) in 32-bit unsigned integer and little endian format, which is then followed by 12 bytes (Byte#8-19) with the &ldquo;IMU6AxisRaw_t&rdquo; data structure defined below:
<code class="prettyprint">c
typedef struct { //3-axis raw data type - 6 bytes
  int16_t Data[3];
} AxesRaw_t;
typedef struct { //6-axis data type - 12 bytes
  AxesRaw_t Acc; //accelerometer
  AxesRaw_t Gyr; //gyroscope
} IMU6AxisRaw_t;
</code>
where &ldquo;AxesRaw_t&rdquo; is the 3-axis raw data type, and &ldquo;IMU6AxisRaw_t&rdquo; is the overall 6-axis IMU data type. Each axis will be a 16-bit signed integer number cast in little endian (least significant byte first). The range of the sensor readings are as follows:
Accelerometer: ±2g (default), Gyroscope: ±2000 dps. The accelerometer range can be changed using another command.</p>

<p>The whole response packet structure including header is shown below:</p>

<table><thead>
<tr>
<th style="text-align: center">Byte 0 (subsystem)</th>
<th style="text-align: center">Byte 1 (length)</th>
<th style="text-align: center">Byte 2 (CRC)</th>
<th style="text-align: center">Byte 3 (command)</th>
<th style="text-align: center">Byte 4-7</th>
<th>Byte 8-19</th>
</tr>
</thead><tbody>
<tr>
<td style="text-align: center">0x01</td>
<td style="text-align: center">0x10</td>
<td style="text-align: center">CRC</td>
<td style="text-align: center">0x03</td>
<td style="text-align: center">TimeStamp</td>
<td>IMU6AxisRaw_t</td>
</tr>
</tbody></table>

<h4 id="quaternion-command-response-0x04">Quaternion Command/Response (0x04)</h4>

<p>In the command mode, the packet enables/disables the streaming of the quaternion data. Byte#8 will be a Boolean value representing the Enable/Disable command. The overall command mode Quaternion packet has the following structure:</p>

<table><thead>
<tr>
<th style="text-align: center">Byte 0 (subsystem)</th>
<th style="text-align: center">Byte 1 (length)</th>
<th style="text-align: center">Byte 2 (CRC)</th>
<th style="text-align: center">Byte 3 (command)</th>
<th style="text-align: center">Byte 4-7</th>
<th style="text-align: center">Byte 8</th>
<th>Bytes 9-19</th>
</tr>
</thead><tbody>
<tr>
<td style="text-align: center">0x41</td>
<td style="text-align: center">0x10</td>
<td style="text-align: center">CRC</td>
<td style="text-align: center">0x04 (Quaternion)</td>
<td style="text-align: center">Reserved</td>
<td style="text-align: center">Enable/Disable</td>
<td>Reserved</td>
</tr>
</tbody></table>

<p>In the response mode, Neblina will first send an acknowledge packet to the host to confirm the successful receipt of the command. Next, the main response packet will be prepared, where the data section first includes 4 bytes for the timestamp (Byte#4-7) in 32-bit unsigned integer and little endian format, which is then followed by 8 bytes (Byte#8-15) with the &ldquo;Quaternion_t&rdquo; data structure defined below:
<code class="prettyprint">c
typedef struct Quaternion_t //quaternion
{
  int16_t q[4]; //fixed-point normalized quaternion with 15 fractional bits
} Quaternion_t;
</code>
The unit-length quaternion contains 4 entries, i.e., \(q = [q_1,q_2,q_3,q_4]\), where \(-1  = q_{1:4} = 1\), and \(q_{12} + q_{22} + q_{32} + q_{42} = 1\).</p>

<p>The real numbers \(q_{1:4}\) are represented using a 16-bit fixed-point number format, where 15-bits are assigned to the fractional part along with a sign bit. Here is an example of how we calculate the 16-bit fixed-point representation of a real number \(x=0.257812\) in the range of \([-1,1]\):</p>

<p>\[xfixp = round(x \times 215) = 8445\]</p>

<p>The integer number \(8445\), which is represented by a 16-bit signed integer number, refers to the real-number \(8445215 = 0.2577209\), which obviously deviates from the actual reference number \(x = 0.257812\). The fixed-point representation error for the number \(x = 0.257812\) is \(0.257812 - 0.2577209 = 0.0000911\).</p>

<p>Using the above approach all real numbers \(q_{1:4}\) are encoded using a 16-bit fixed-point representation and 15 fractional bits. The bytes are once again packed into the packet in little endian format (least significant byte first).</p>

<p>The whole response packet structure including header is shown below:</p>

<table><thead>
<tr>
<th style="text-align: center">Byte 0 (subsystem)</th>
<th style="text-align: center">Byte 1 (length)</th>
<th style="text-align: center">Byte 2 (CRC)</th>
<th style="text-align: center">Byte 3 (command)</th>
<th style="text-align: center">Byte 4-7</th>
<th>Byte 8-15</th>
<th>Bytes 16-19</th>
</tr>
</thead><tbody>
<tr>
<td style="text-align: center">0x01</td>
<td style="text-align: center">0x10</td>
<td style="text-align: center">CRC</td>
<td style="text-align: center">0x04</td>
<td style="text-align: center">TimeStamp</td>
<td>Quaternion_t</td>
<td>Reserved</td>
</tr>
</tbody></table>

<h4 id="eulerangle-command-response-0x05">EulerAngle Command/Response (0x05)</h4>

<p>In the command mode, the packet enables/disables the streaming of the Euler Angle data. Byte#8 will be a Boolean value representing the Enable/Disable command. The overall command mode Euler Angle packet has the following structure:</p>

<table><thead>
<tr>
<th style="text-align: center">Byte 0 (subsystem)</th>
<th style="text-align: center">Byte 1 (length)</th>
<th style="text-align: center">Byte 2 (CRC)</th>
<th style="text-align: center">Byte 3 (command)</th>
<th style="text-align: center">Byte 4-7</th>
<th style="text-align: center">Byte 8</th>
<th>Bytes 9-19</th>
</tr>
</thead><tbody>
<tr>
<td style="text-align: center">0x41</td>
<td style="text-align: center">0x10</td>
<td style="text-align: center">CRC</td>
<td style="text-align: center">0x05 (Euler Angle)</td>
<td style="text-align: center">Reserved</td>
<td style="text-align: center">Enable/Disable</td>
<td>Reserved</td>
</tr>
</tbody></table>

<p>In the response mode, Neblina will first send an acknowledge packet to the host to confirm the successful receipt of the command. Next, the main response packet will be prepared, where the data section first includes 4 bytes for the timestamp (Byte#4-7), which is then followed by 6 bytes (Byte#8-13) with the &ldquo;Euler_fxp_t&rdquo; data structure defined below:
<code class="prettyprint">c
typedef struct Euler_fxp_t //fixed-point Euler angles, i.e., round(angle*10)
{
  int16_t yaw; //first rotation, around z-axis
  int16_t pitch; //second rotation, around y-axis
  int16_t roll; //third rotation, around x-axis
} Euler_fxp_t;
</code>
The orientation can easily be visualized using Euler angles, which can be found from the quaternion orientation. The Euler angles are reported in the so-called aerospace sequence, where the Yaw rotation (around z-axis) takes place first, which is then followed by Pitch (rotation around y-axis) and then Roll (rotation around x-axis). Each Euler angle is represented by 16 bits. The Euler angles are read in degrees and they have the following ranges: \(Yaw \in [-180,180]\), \(Pitch \in [-90,90]\), \(Roll \in [-180,180]\).</p>

<p>The angles are represented by one fractional digit precision using the following equation:</p>

<p>\[angle_est = round(angle_ref \times 10)\]</p>

<p>For instance, the angle \(-104.731^{\circ}\) is rounded to \(-104.8^{\circ}\), and is represented using 16-bit signed integer format as the number -1048. The 16-bit signed integer numbers representing angles are once again packet in little endian format, i.e., the least significant byte is placed first.</p>

<p>The whole response packet structure including header is shown below:</p>

<table><thead>
<tr>
<th style="text-align: center">Byte 0 (subsystem)</th>
<th style="text-align: center">Byte 1 (length)</th>
<th style="text-align: center">Byte 2 (CRC)</th>
<th style="text-align: center">Byte 3 (command)</th>
<th style="text-align: center">Byte 4-7</th>
<th style="text-align: center">Byte 8-15</th>
<th style="text-align: center">Bytes 14-19</th>
</tr>
</thead><tbody>
<tr>
<td style="text-align: center">0x01</td>
<td style="text-align: center">0x10</td>
<td style="text-align: center">CRC</td>
<td style="text-align: center">0x05</td>
<td style="text-align: center">TimeStamp</td>
<td style="text-align: center">Euler_fxp_t</td>
<td style="text-align: center">Reserved</td>
</tr>
</tbody></table>

<h4 id="extforce-command-response-0x06">ExtForce Command/Response (0x06)</h4>

<p>In the command mode, the packet enables/disables the streaming of the external force vector. Byte#8 will be a Boolean value representing the Enable/Disable command. The overall command mode External Force packet has the following structure:</p>

<table><thead>
<tr>
<th style="text-align: center">Byte 0 (subsystem)</th>
<th style="text-align: center">Byte 1 (length)</th>
<th style="text-align: center">Byte 2 (CRC)</th>
<th style="text-align: center">Byte 3 (command)</th>
<th style="text-align: center">Byte 4-7</th>
<th style="text-align: center">Byte 8</th>
<th>Bytes 9-19</th>
</tr>
</thead><tbody>
<tr>
<td style="text-align: center">0x41</td>
<td style="text-align: center">0x10</td>
<td style="text-align: center">CRC</td>
<td style="text-align: center">0x06 (ExtForce)</td>
<td style="text-align: center">Reserved</td>
<td style="text-align: center">Enable/Disable</td>
<td>Reserved</td>
</tr>
</tbody></table>

<p>In the response mode, Neblina will first send an acknowledge packet to the host to confirm the successful receipt of the command. Next, the main response packet will be prepared, where the data section first includes 4 bytes for the timestamp (Byte#4-7), which is then followed by 6 bytes (Byte#8-13) with the &ldquo;Fext_Vec16_t&rdquo; data structure defined below:
<code class="prettyprint">c
typedef struct Fext_Vec16_t { //external force vector
int16_t x;
int16_t y;
int16_t z;
}Fext_Vec16_t;
</code>
The accelerometer data captures the total force vector applied to the device including gravity. The x, y, z components of the external force vector are defined in the reference Earth frame (not the sensor body frame). This means that regardless of the device&rsquo;s orientation, this force vector aligns with the fixed reference Earth frame and can be used for position tracking, etc. The external force components, x, y, z are 16-bit signed integer numbers covering the range of [-1g,1g]. This is due to the fact that the accelerometer data range is set to [-2g,2g], while the gravity vector is (0,0,1g). The 16-bit signed integer numbers are packed into bytes in little endian format.</p>

<p>The whole response packet structure including header is shown below:</p>

<table><thead>
<tr>
<th style="text-align: center">Byte 0 (subsystem)</th>
<th style="text-align: center">Byte 1 (length)</th>
<th style="text-align: center">Byte 2 (CRC)</th>
<th style="text-align: center">Byte 3 (command)</th>
<th style="text-align: center">Byte 4-7</th>
<th>Byte 8-13</th>
<th>Bytes 14-19</th>
</tr>
</thead><tbody>
<tr>
<td style="text-align: center">0x01</td>
<td style="text-align: center">0x10</td>
<td style="text-align: center">CRC</td>
<td style="text-align: center">0x06</td>
<td style="text-align: center">TimeStamp</td>
<td>Fext_Vec16_t</td>
<td>Reserved</td>
</tr>
</tbody></table>

<h4 id="setfusiontype-command-0x07">SetFusionType Command (0x07)</h4>

<p>The corresponding packet&rsquo;s data section includes only 1 byte (Byte #8), indicating whether the fusion should be set to either 6-axis IMU or 9-axis MARG mode involving magnetometers:</p>

<h5 id="byte-8-6-axis-imu-mode-0-or-9-axis-marg-mode-1">Byte#8: 6-axis IMU mode (0) or 9-axis MARG mode (1)</h5>

<p>The overall packet structure is as follows:</p>

<table><thead>
<tr>
<th style="text-align: center">Byte 0 (subsystem)</th>
<th style="text-align: center">Byte 1 (length)</th>
<th style="text-align: center">Byte 2 (CRC)</th>
<th style="text-align: center">Byte 3 (command)</th>
<th style="text-align: center">Byte 4-7</th>
<th style="text-align: center">Byte 8</th>
<th>Bytes 9-19</th>
</tr>
</thead><tbody>
<tr>
<td style="text-align: center">0x41</td>
<td style="text-align: center">0x10</td>
<td style="text-align: center">CRC</td>
<td style="text-align: center">0x07 (SetFusionType)</td>
<td style="text-align: center">Reserved</td>
<td style="text-align: center">IMU/MARG</td>
<td>Reserved</td>
</tr>
</tbody></table>

<p>In response, Neblina will only send an acknowledge/error packet to indicate the validity and receipt of the command issued by the host.</p>

<h4 id="trajectoryrecstartstop-0x08">TrajectoryRecStartStop (0x08)</h4>

<p>The corresponding packet&rsquo;s data section includes only 1 byte (Byte#8), to determine the start (1) or stop (0) of the orientation recording process. The overall packet structure is as follows:</p>

<table><thead>
<tr>
<th style="text-align: center">Byte 0 (subsystem)</th>
<th style="text-align: center">Byte 1 (length)</th>
<th style="text-align: center">Byte 2 (CRC)</th>
<th style="text-align: center">Byte 3 (command)</th>
<th style="text-align: center">Byte 4-7</th>
<th style="text-align: center">Byte 8</th>
<th>Bytes 9-19</th>
</tr>
</thead><tbody>
<tr>
<td style="text-align: center">0x41</td>
<td style="text-align: center">0x10</td>
<td style="text-align: center">CRC</td>
<td style="text-align: center">0x08 (TrajectoryRecStartStop)</td>
<td style="text-align: center">Reserved</td>
<td style="text-align: center">start/stop</td>
<td>Reserved</td>
</tr>
</tbody></table>

<p>In response, Neblina will only send an acknowledge/error packet to indicate the validity and receipt of the command issued by the host.</p>

<h4 id="trajectoryinfo-command-response-0x09">TrajectoryInfo Command/Response (0x09)</h4>

<p>In the command mode, the packet enables/disables the streaming of the distance from a pre-recorded orientation trajectory, as well as the progress report. Byte#8 will be a Boolean value representing the Enable/Disable command. The overall command mode TrajectoryDistance packet has the following structure:</p>

<table><thead>
<tr>
<th style="text-align: center">Byte 0 (subsystem)</th>
<th style="text-align: center">Byte 1 (length)</th>
<th style="text-align: center">Byte 2 (CRC)</th>
<th style="text-align: center">Byte 3 (command)</th>
<th style="text-align: center">Byte 4-7</th>
<th style="text-align: center">Byte 8</th>
<th>Bytes 9-19</th>
</tr>
</thead><tbody>
<tr>
<td style="text-align: center">0x41</td>
<td style="text-align: center">0x10</td>
<td style="text-align: center">CRC</td>
<td style="text-align: center">0x09 (Trajectory)</td>
<td style="text-align: center">Reserved</td>
<td style="text-align: center">Enable/Disable</td>
<td>Reserved</td>
</tr>
</tbody></table>

<p>In the response mode, Neblina will first send an acknowledge packet to the host to confirm the successful receipt of the command. Next, the main response packet will be prepared, where the data section first includes 4 bytes for the timestamp (Byte#4-7), which is then followed by 6 bytes (Byte#8-13) representing the Euler angle errors in yaw (Byte#8-9), pitch (Byte#10-11), and roll (Byte#12-13) in degrees. Each angle error is a 16-bit signed integer number and it is packed into 2 bytes in little endian format. The next 2 bytes (Byte#14-15) represent a 16-bit unsigned integer number in little endian format showing how many times the recorded track has been repeated. Finally, Byte#16 shows the percentage of completion indicating how much of the recorded track has been covered. The track Counter (Byte#14-15) will be increased by 1, and the percentage value will drop back to zero, when the full track is covered. The whole response packet structure including header is shown below:</p>

<table><thead>
<tr>
<th style="text-align: center">Byte 0 (subsystem)</th>
<th style="text-align: center">Byte 1 (length)</th>
<th style="text-align: center">Byte 2</th>
<th style="text-align: center">Byte 3</th>
<th style="text-align: center">Byte 4-7</th>
<th style="text-align: center">Byte 8-13</th>
<th style="text-align: center">Byte 14-15</th>
<th style="text-align: center">Byte 16</th>
<th style="text-align: center">Bytes 17-19</th>
</tr>
</thead><tbody>
<tr>
<td style="text-align: center">0x01</td>
<td style="text-align: center">0x10</td>
<td style="text-align: center">CRC</td>
<td style="text-align: center">0x09</td>
<td style="text-align: center">TimeStamp</td>
<td style="text-align: center">EulerAngle Errors</td>
<td style="text-align: center">Counter</td>
<td style="text-align: center">Progress</td>
<td style="text-align: center">Reserved</td>
</tr>
</tbody></table>

<h4 id="pedometer-command-response-0x0a">Pedometer Command/Response (0x0A)</h4>

<p>In the command mode, the packet enables/disables the streaming of the Pedometer data. Byte#8 will be a Boolean value representing the Enable/Disable command. The overall command mode Pedometer packet has the following structure:</p>

<table><thead>
<tr>
<th style="text-align: center">Byte 0 (subsystem)</th>
<th style="text-align: center">Byte 1 (length)</th>
<th style="text-align: center">Byte 2 (CRC)</th>
<th style="text-align: center">Byte 3 (command)</th>
<th style="text-align: center">Byte 4-7</th>
<th style="text-align: center">Byte 8</th>
<th>Bytes 9-19</th>
</tr>
</thead><tbody>
<tr>
<td style="text-align: center">0x41</td>
<td style="text-align: center">0x10</td>
<td style="text-align: center">CRC</td>
<td style="text-align: center">0x0A (Pedometer)</td>
<td style="text-align: center">Reserved</td>
<td style="text-align: center">Enable/Disable</td>
<td>Reserved</td>
</tr>
</tbody></table>

<p>In the response mode, Neblina will first send an acknowledge packet to the host to confirm the successful receipt of the command. Next, the main response packet will be prepared, where the data section first includes 4 bytes for the current timestamp (Byte#4-7), which is then followed by 9 bytes (Byte#8-16) with the following subfields:</p>

<h5 id="byte-8-step-count-lsb">Byte#8: step count, LSB</h5>

<h5 id="byte-9-step-count-msb">Byte#9: step count, MSB</h5>

<h5 id="byte-10-spm-cadence">Byte#10: spm (Cadence)</h5>

<h5 id="byte-11-walking-direction-angle-value-lsb">Byte#11: walking direction angle value LSB</h5>

<h5 id="byte-12-walking-direction-angle-value-msb">Byte#12: walking direction angle value MSB</h5>

<h5 id="byte-13-16-timestamp-in-microseconds-associated-with-the-toe-off-moment-in-the-current-step-cycle">Byte#13-16: Timestamp in microseconds associated with the toe-off moment in the current step cycle.</h5>

<p>Note that the angle format is a 16-bit signed integer value within the range of [-1800,1800], which represents the heading angle multiplied by 10, i.e., including one decimal fractional digit. For instance, the value of 1723 represents 172.3 degrees. Furthermore, it is notable that when we disable the pedometer streaming, the step count value will be reset to zero. The whole response packet structure including header is shown below:</p>

<table><thead>
<tr>
<th style="text-align: center">Byte 0</th>
<th style="text-align: center">Byte 1</th>
<th style="text-align: center">Byte 2</th>
<th style="text-align: center">Byte 3</th>
<th style="text-align: center">Byte 4-7</th>
<th style="text-align: center">Byte 8-9</th>
<th style="text-align: center">Byte 10</th>
<th style="text-align: center">Byte 11-12</th>
<th style="text-align: center">Byte 13-16</th>
<th style="text-align: center">Bytes 17-19</th>
</tr>
</thead><tbody>
<tr>
<td style="text-align: center">0x01</td>
<td style="text-align: center">0x10</td>
<td style="text-align: center">CRC</td>
<td style="text-align: center">0x0A</td>
<td style="text-align: center">TimeStamp</td>
<td style="text-align: center">step count</td>
<td style="text-align: center">cadence</td>
<td style="text-align: center">direction angle</td>
<td style="text-align: center">Toe-off TimeStamp</td>
<td style="text-align: center">Reserved</td>
</tr>
</tbody></table>

<h4 id="mag_data-command-response-0x0b">MAG_Data Command/Response (0x0B)</h4>

<p>In the command mode, the packet enables/disables the streaming of the 3-axis magnetometer data along with the 3-axis accelerometer data. Byte#8 will be a Boolean value representing the Enable/Disable command. The overall command mode MAG_Data packet has the following structure:</p>

<table><thead>
<tr>
<th style="text-align: center">Byte 0 (subsystem)</th>
<th style="text-align: center">Byte 1 (length)</th>
<th style="text-align: center">Byte 2 (CRC)</th>
<th style="text-align: center">Byte 3 (command)</th>
<th style="text-align: center">Byte 4-7</th>
<th style="text-align: center">Byte 8</th>
<th>Bytes 9-19</th>
</tr>
</thead><tbody>
<tr>
<td style="text-align: center">0x41</td>
<td style="text-align: center">0x10</td>
<td style="text-align: center">CRC</td>
<td style="text-align: center">0x0B (MAG_Data)</td>
<td style="text-align: center">Reserved</td>
<td style="text-align: center">Enable/Disable</td>
<td>Reserved</td>
</tr>
</tbody></table>

<p>In the response mode, Neblina will first send an acknowledge packet to the host to confirm the successful receipt of the command. Next, the main response packet will be prepared, where the data section first includes 4 bytes for the timestamp (Byte#4-7), which is then followed by 2*6 bytes (Byte#8-19) with the &ldquo;AxesRaw_t&rdquo; data structure defined before in the IMU_Data Command section. The first 6 bytes (Byte#8-13) will be a &ldquo;AxesRaw_t&rdquo; data structure for magnetometers, and the next 6 bytes (Byte#14-19) will be another &ldquo;AxesRaw_t&rdquo; data structure for accelerometer data. All the bytes are packed in little endian format. Note that the magnetoneter reading in each axis is a 16-bit signed integer representing the range: ±4 gauss.</p>

<p>The whole response packet structure including header is shown below:</p>

<table><thead>
<tr>
<th style="text-align: center">Byte 0 (subsystem)</th>
<th style="text-align: center">Byte 1 (length)</th>
<th style="text-align: center">Byte 2 (CRC)</th>
<th style="text-align: center">Byte 3 (command)</th>
<th style="text-align: center">Byte 4-7</th>
<th style="text-align: center">Byte 8-13</th>
<th style="text-align: center">Bytes 14-19</th>
</tr>
</thead><tbody>
<tr>
<td style="text-align: center">0x01</td>
<td style="text-align: center">0x10</td>
<td style="text-align: center">CRC</td>
<td style="text-align: center">0x0B</td>
<td style="text-align: center">TimeStamp</td>
<td style="text-align: center">AxesRaw_t (Mag)</td>
<td style="text-align: center">AxesRaw_t (Acc)</td>
</tr>
</tbody></table>

<h4 id="sittingstanding-command-response-0x0c">SittingStanding Command/Response (0x0C)</h4>

<p>In the command mode, the packet enables/disables the streaming of sitting/standing modes. Byte#8 will be a Boolean value representing the Enable/Disable command. The overall command mode SittingStanding packet has the following structure:</p>

<table><thead>
<tr>
<th style="text-align: center">Byte 0 (subsystem)</th>
<th style="text-align: center">Byte 1 (length)</th>
<th style="text-align: center">Byte 2 (CRC)</th>
<th style="text-align: center">Byte 3 (command)</th>
<th style="text-align: center">Byte 4-7</th>
<th style="text-align: center">Byte 8</th>
<th>Bytes 9-19</th>
</tr>
</thead><tbody>
<tr>
<td style="text-align: center">0x41</td>
<td style="text-align: center">0x10</td>
<td style="text-align: center">CRC</td>
<td style="text-align: center">0x0C (SittingStanding)</td>
<td style="text-align: center">Reserved</td>
<td style="text-align: center">Enable/Disable</td>
<td>Reserved</td>
</tr>
</tbody></table>

<p>In the response mode, Neblina will first send an acknowledge packet to the host to confirm the successful receipt of the command. Next, the main response packet will be prepared, where the data section first includes 4 bytes for the timestamp (Byte#4-7), which is then followed by a single byte (Byte#8) indicating whether the person has just stood up (Byte#8 = 0x01), or has just sat down (Byte#8 = 0x00). If the person remains standing/sitting, no response packet will be sent to the host.  Next, we have 4 bytes (Byte#9-12), a 32-bit unsigned integer value packed in little endian format (LSB first), representing the amount of time in seconds the person has been sitting so far (SitTime). The next 4 bytes (Byte#13-16) construct another 32-bit unsigned integer in little endian format, which represents the amount of time in seconds the person has been standing up so far (StandTime). 
Note that if the host disables the streaming of sitting/standing mode, the SitTime and StandTime will be both reset to zero. The last 3 bytes of the packet (Byte#17-19) are reserved. The whole response packet structure including header is shown below:</p>

<table><thead>
<tr>
<th style="text-align: center">Byte 0</th>
<th style="text-align: center">Byte 1</th>
<th style="text-align: right">Byte 2</th>
<th style="text-align: center">Byte 3</th>
<th style="text-align: center">Byte 4-7</th>
<th style="text-align: center">Byte 8</th>
<th style="text-align: center">Byte 9-12</th>
<th style="text-align: center">Byte 13-16</th>
<th style="text-align: center">Bytes 17-19</th>
</tr>
</thead><tbody>
<tr>
<td style="text-align: center">0x01</td>
<td style="text-align: center">0x10</td>
<td style="text-align: right">CRC</td>
<td style="text-align: center">0x0C</td>
<td style="text-align: center">TimeStamp</td>
<td style="text-align: center">Sit/Stand</td>
<td style="text-align: center">SitTime</td>
<td style="text-align: center">StandTime</td>
<td style="text-align: center">Reserved</td>
</tr>
</tbody></table>

<h4 id="lockheadingref-command-0x0d">LockHeadingRef Command (0x0D)</h4>

<p>Neblina provides the option to lock magnetometer readings to represent the 0 degrees reference heading. When this command is issued, Neblina will wait until the device is positioned on either a horizontal or vertical plane and then the current magnetometer readings will be locked to the zero degrees heading. Therefore, whenever the device points back to the same direction, Neblina will provide correction for the heading angle to reach the reference 0 degrees. The correction is adaptive meaning that if the deviation of the heading angle caused by the Gyroscopes&rsquo; drift is high enough at the reference heading angle, the correction will be aggressive. However, if the heading info is close to the zero degrees (&lt;15 degrees), the correction will apply smoothly. The full command packet has the following structure:</p>

<table><thead>
<tr>
<th style="text-align: center">Byte 0 (subsystem)</th>
<th style="text-align: center">Byte 1 (length)</th>
<th style="text-align: center">Byte 2</th>
<th style="text-align: center">Byte 3 (command)</th>
<th style="text-align: center">Byte 4-19</th>
</tr>
</thead><tbody>
<tr>
<td style="text-align: center">0x41</td>
<td style="text-align: center">0x10</td>
<td style="text-align: center">CRC</td>
<td style="text-align: center">0x0D (LockHeadingRef)</td>
<td style="text-align: center">Reserved</td>
</tr>
</tbody></table>

<p>In response, Neblina will only send an acknowledge packet to indicate the successful receipt of the command issued by the host.</p>

<h4 id="setaccrange-command-0x0e">SetAccRange Command (0x0E)</h4>

<p>This command sets the accelerometer full-scale range to either 2G (Mode 0), 4G (Mode 1), 8G (Mode 2), or 16G (Mode 3). The default mode is 2G. Byte#8 will be set to 0, 1, 2, or 3, representing the mode. The overall SetAccRange packet has the following structure:</p>

<table><thead>
<tr>
<th style="text-align: center">Byte 0 (subsystem)</th>
<th style="text-align: center">Byte 1 (length)</th>
<th style="text-align: center">Byte 2 (CRC)</th>
<th style="text-align: center">Byte 3 (command)</th>
<th style="text-align: center">Byte 4-7</th>
<th style="text-align: center">Byte 8</th>
<th>Bytes 9-19</th>
</tr>
</thead><tbody>
<tr>
<td style="text-align: center">0x41</td>
<td style="text-align: center">0x10</td>
<td style="text-align: center">CRC</td>
<td style="text-align: center">0x0E (SetAccRange)</td>
<td style="text-align: center">Reserved</td>
<td style="text-align: center">Mode</td>
<td>Reserved</td>
</tr>
</tbody></table>

<p>In response, Neblina will only send an acknowledge/error packet to indicate the validity and receipt of the command issued by the host.</p>

<h4 id="disableallstreaming-command-0x0f">DisableAllStreaming Command (0x0F)</h4>

<p>This command disables all the streaming options in the motion engine. The command is useful for the host applications to ensure that there is no streaming traffic on the physical layer. The data section for this command is empty. The full command packet has the following structure:</p>

<table><thead>
<tr>
<th style="text-align: center">Byte 0 (subsystem)</th>
<th style="text-align: center">Byte 1 (length)</th>
<th style="text-align: center">Byte 2</th>
<th style="text-align: center">Byte 3 (command)</th>
<th style="text-align: center">Byte 4-19</th>
</tr>
</thead><tbody>
<tr>
<td style="text-align: center">0x41</td>
<td style="text-align: center">0x10</td>
<td style="text-align: center">CRC</td>
<td style="text-align: center">0x0F (DisableAllStreaming)</td>
<td style="text-align: center">Reserved</td>
</tr>
</tbody></table>

<h4 id="resettimestamp-command-0x10">ResetTimeStamp Command (0x10)</h4>

<p>This commands resets the timestamp value to zero. The command is useful for the host application to synchronize with the motion engine&rsquo;s timestamp. The data section for this command is empty. The full command packet has the following structure:</p>

<table><thead>
<tr>
<th style="text-align: center">Byte 0 (subsystem)</th>
<th style="text-align: center">Byte 1 (length)</th>
<th style="text-align: center">Byte 2</th>
<th style="text-align: center">Byte 3 (command)</th>
<th style="text-align: center">Byte 4-19</th>
</tr>
</thead><tbody>
<tr>
<td style="text-align: center">0x41</td>
<td style="text-align: center">0x10</td>
<td style="text-align: center">CRC</td>
<td style="text-align: center">0x10 (ResetTimeStamp)</td>
<td style="text-align: center">Reserved</td>
</tr>
</tbody></table>

<h4 id="fingergesture-command-0x11">FingerGesture Command (0x11)</h4>

<p>In the command mode, this packet enables/disables the streaming of the finger gesture patterns, when Neblina is attached to a finger. Currently, the patterns that are being detected are the Swipe Left, Swipe Right, Swipe Up, Swipe Down, Flip Right (clock-wise), Flip Left (counter clock-wise), and Double Tap. Byte#8 will be a Boolean value representing the enable/disable command. The whole command packet has the following structure: </p>

<table><thead>
<tr>
<th style="text-align: center">Byte 0 (subsystem)</th>
<th style="text-align: center">Byte 1 (length)</th>
<th style="text-align: center">Byte 2 (CRC)</th>
<th style="text-align: center">Byte 3 (command)</th>
<th style="text-align: center">Byte 4-7</th>
<th style="text-align: center">Byte 8</th>
<th style="text-align: right">Bytes 9-19</th>
</tr>
</thead><tbody>
<tr>
<td style="text-align: center">0x41</td>
<td style="text-align: center">0x10</td>
<td style="text-align: center">CRC</td>
<td style="text-align: center">0x11 (FingerGesture)</td>
<td style="text-align: center">Reserved</td>
<td style="text-align: center">Enable/Disable</td>
<td style="text-align: right">Reserved</td>
</tr>
</tbody></table>

<p>In the response mode, Neblina will first send an acknowledge packet to the host to confirm the successful receipt of the command. Next, only when a new finger gesture pattern has been detected, and if the streaming is enabled, a response packet will be prepared with the pattern information and will be sent to the host. The response packet includes the timestamp (Byte#4-7), as well as the pattern information (Byte#8), where </p>
<pre class="highlight c"><code><span class="n">Byte</span><span class="err">#</span><span class="mi">8</span> <span class="p">(</span><span class="n">Pattern</span><span class="p">)</span><span class="o">:</span> 
<span class="n">Swipe</span> <span class="n">Left</span>  <span class="o">=</span> <span class="mh">0x00</span> 
<span class="n">Swipe</span> <span class="n">Right</span> <span class="o">=</span> <span class="mh">0x01</span>
<span class="n">Swipe</span> <span class="n">Up</span>    <span class="o">=</span> <span class="mh">0x02</span> 
<span class="n">Swipe</span> <span class="n">Down</span>  <span class="o">=</span> <span class="mh">0x03</span>
<span class="n">Flip</span> <span class="n">Left</span>   <span class="o">=</span> <span class="mh">0x04</span>
<span class="n">Flip</span> <span class="n">Right</span>  <span class="o">=</span> <span class="mh">0x05</span>
<span class="n">Double</span> <span class="n">Tap</span>  <span class="o">=</span> <span class="mh">0x06</span>
</code></pre>

<p>The whole response packet is as follows:</p>

<table><thead>
<tr>
<th style="text-align: center">Byte 0 (subsystem)</th>
<th style="text-align: center">Byte 1 (length)</th>
<th style="text-align: center">Byte 2 (CRC)</th>
<th style="text-align: center">Byte 3 (command)</th>
<th style="text-align: center">Byte 4-7</th>
<th style="text-align: center">Byte 8</th>
<th style="text-align: center">Bytes 9-19</th>
</tr>
</thead><tbody>
<tr>
<td style="text-align: center">0x01</td>
<td style="text-align: center">0x10</td>
<td style="text-align: center">CRC</td>
<td style="text-align: center">0x11</td>
<td style="text-align: center">TimeStamp</td>
<td style="text-align: center">Pattern</td>
<td style="text-align: center">Reserved</td>
</tr>
</tbody></table>

<h4 id="rotationinfo-command-0x12">RotationInfo Command (0x12)</h4>

<p>In the command mode, this packet enables/disables the streaming of the device&rsquo;s rotation information in roll. This is useful, when Neblina is attached to a wheel for instance for tracking the number of rotations and speed. Byte#8 will be a Boolean value representing the Enable/Disable command. The overall command mode RotationInfo packet has the following structure:  </p>

<table><thead>
<tr>
<th style="text-align: center">Byte 0 (subsystem)</th>
<th style="text-align: center">Byte 1 (length)</th>
<th style="text-align: center">Byte 2 (CRC)</th>
<th style="text-align: center">Byte 3 (command)</th>
<th style="text-align: center">Byte 4-7</th>
<th style="text-align: center">Byte 8</th>
<th>Bytes 9-19</th>
</tr>
</thead><tbody>
<tr>
<td style="text-align: center">0x41</td>
<td style="text-align: center">0x10</td>
<td style="text-align: center">CRC</td>
<td style="text-align: center">0x12 (RotationInfo)</td>
<td style="text-align: center">Reserved</td>
<td style="text-align: center">Enable/Disable</td>
<td>Reserved</td>
</tr>
</tbody></table>

<p>In the response mode, Neblina will first send an acknowledge packet to the host to confirm the successful receipt of the command. Next, the main response packet will be prepared, where the data section first includes 4 bytes for the timestamp (Byte#4-7), which is then followed by 6 bytes (Byte#8-13) with the following subfields:</p>

<h5 id="byte-8-11-total-number-of-rotations-as-a-32-bit-unsigned-integer">Byte#8-11: total number of rotations as a 32-bit unsigned integer</h5>

<h5 id="byte-12-13-rpm-rounds-per-minute-speed-multiplied-by-10-as-a-16-bit-unsigned-integer">Byte#12-13: rpm (rounds per minute) speed multiplied by 10, as a 16-bit unsigned integer</h5>

<p>For instance, if Byte#12-13 read rpm as the decimal value of 578, it means that the actual rpm is 57.8. This gives one fractional decimal digit precision in calculation of the rpm. </p>

<p>Note also that when we disable the rotation information streaming, the rotation count will be reset to zero. The whole response packet including header is shown below:</p>

<table><thead>
<tr>
<th style="text-align: center">Byte 0</th>
<th style="text-align: center">Byte 1</th>
<th style="text-align: center">Byte 2</th>
<th style="text-align: center">Byte 3</th>
<th style="text-align: center">Byte 4-7</th>
<th style="text-align: center">Byte 8-11</th>
<th style="text-align: center">Byte 12-13</th>
<th style="text-align: center">Bytes 14-19</th>
</tr>
</thead><tbody>
<tr>
<td style="text-align: center">0x01</td>
<td style="text-align: center">0x10</td>
<td style="text-align: center">CRC</td>
<td style="text-align: center">0x12</td>
<td style="text-align: center">TimeStamp</td>
<td style="text-align: center">rotation count</td>
<td style="text-align: center">rpm*10 (speed)</td>
<td style="text-align: center">Reserved</td>
</tr>
</tbody></table>

<h4 id="extrnheadingcorrection-0x13">ExtrnHeadingCorrection (0x13)</h4>

<p>This command lets the host provide an external source of information to Neblina to correct its heading angle. The heading angle is provided in degrees with one fractional decimal digit precision as a 16-bit signed integer value (Byte 8-9). The command also provides an average absolute error expected in the reference heading angle that is in degrees as well and has one fractional decimal digit precision (16-bit unsigned integer within Byte 10-11). The heading angle, which is a 16-bit signed integer value, lies within the range of [-1800,1800] representing the angle in degrees multiplied by 10, i.e., including one decimal fractional digit. For instance, the value of 1723 represents 172.3 degrees. The angle Error is a positive value (16-bit unsigned integer) and lies in the range of [0,1800] with the same precision. For instance, the Error value of 26 represents the error of 2.6 degrees. The overall command mode ExtrnHeadingCorrection packet has the following structure:</p>

<table><thead>
<tr>
<th style="text-align: center">Byte 0 (subsystem)</th>
<th style="text-align: center">Byte 1 (length)</th>
<th style="text-align: center">Byte 2 (CRC)</th>
<th style="text-align: center">Byte 3 (command)</th>
<th style="text-align: center">Byte 4-7</th>
<th style="text-align: center">Byte 8-9</th>
<th style="text-align: center">Bytes 10-11</th>
<th style="text-align: center">Byte 12-19</th>
</tr>
</thead><tbody>
<tr>
<td style="text-align: center">0x41</td>
<td style="text-align: center">0x10</td>
<td style="text-align: center">CRC</td>
<td style="text-align: center">0x13 (ExtrnHeadingCorrection)</td>
<td style="text-align: center">Reserved</td>
<td style="text-align: center">Heading Angle</td>
<td style="text-align: center">Error</td>
<td style="text-align: center">Reserved</td>
</tr>
</tbody></table>

<p>The response is either an Ack or NAck packet depending on whether Neblina accepts the external heading or not. If Neblina is under a quick motion and change in the heading angle, while the external heading angle correction arrives, it will reject the correction and send a NAck packet back to the host. Otherwise, it will gradually and adaptively apply the correction to its current state depending on the Error (Byte 10-11) in the command as well as the error between the current estimate and the external angle. The correction will be very smooth and adaptive, avoiding any quick jumps in the heading angle state. </p>

      </div>
      <div class="dark-box">
      </div>
    </div>
  </body>
</html>
