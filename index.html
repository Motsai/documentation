<!doctype html>
<html>
  <head>
    <meta charset="utf-8">
    <meta content="IE=edge,chrome=1" http-equiv="X-UA-Compatible">
    <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
    <title>Neblina API Reference</title>

    <link href="stylesheets/screen.css" rel="stylesheet" type="text/css" media="screen" />
    <link href="stylesheets/print.css" rel="stylesheet" type="text/css" media="print" />
    <script src="https://ajax.googleapis.com/ajax/libs/jquery/2.1.3/jquery.min.js"></script>
      <script src="javascripts/all.js" type="text/javascript"></script>

      <script>
        $(function() {
          setupLanguages(["C"]);
        });
      </script>

    <script type="text/javascript" src="http://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML">
    </script>
  </head>

  <body class="index">
    <a href="#" id="nav-button">
      <span>
        NAV
        <img src="images/navbar.png" />
      </span>
    </a>
    <div class="tocify-wrapper">
     <a href="http://www.motsai.com">
      <img src="images/logo.png" />
     </a>
        <div class="lang-selector">
              <a href="#" data-language-name="C">C code</a>
        </div>
        <div class="search">
          <input type="text" class="search" id="input-search" placeholder="Search">
        </div>
        <ul class="search-results"></ul>
      <div id="toc">
      </div>
        <ul class="toc-footer">
            <li><a href='http://www.motsai.com'>&copy; Motsai.</a> All Rights Reserved</li>
            <li><a href='http://github.com/tripit/slate'>Documentation Powered by Slate</a></li>
        </ul>
    </div>
    <div class="page-wrapper">
      <div class="dark-box"></div>
      <div class="content">
        <h1 id="introduction">Introduction</h1>

<p>The developers can issue commands to Neblina through the BLE interface and ask for a variety of information by calling the appropriate API functions. The host application makes use of these high-level API functions to ask Neblina to stream different types of data through the BLE interface. By default all streaming features are disabled. We can also request the status of the subsystems on Neblina to check if there has been an invalid command issued in the past by the host. This document explains how developers can make use of these API functions.</p>

<p>Two main subsystems are defined on Neblina: the motion engine and the power management subsystem. All the API functions related to the motion engine are summarized in the <code class="prettyprint">motion_engine_api.h</code> file, while the power management APIs are addressed in the <code class="prettyprint">power_api.h</code> file. The data structures associated with the motion engine and power management APIs are addressed in two files: <code class="prettyprint">neblina.h</code> and <code class="prettyprint">FusionEngineDataTypes.h</code>.</p>

          <h1 id="motion-engine-api">Motion Engine API</h1>

<h2 id="down-sample-stream">Down sample stream</h2>

<p><code class="prettyprint">DownsampleStream(uint16_t n)</code></p>

<p>This function sets the streaming frequency divider. The streaming base frequency is 1KHz, and this function will set the frequency to 1000/n Hz. Currently, the default value of <code class="prettyprint">n</code> is 20 and the acceptable values for <code class="prettyprint">n</code> are integer multiples of 20, i.e., n = 20, 40, 60, etc. If n is set to another value, Neblina will log this as an error. The host can issue commands to request for the error logs as well, which will be explained later.</p>

<h2 id="enable-motion-stream">Enable motion stream</h2>

<blockquote>
<p>The motion status has the following type will be streamed:</p>
</blockquote>
<pre class="highlight c"><code><span class="k">typedef</span> <span class="k">enum</span> <span class="p">{</span>
  <span class="n">No_Change</span> <span class="o">=</span> <span class="p">(</span><span class="kt">uint8_t</span><span class="p">)</span><span class="mh">0x00</span><span class="p">,</span> <span class="c1">//holds its previous state
</span>  <span class="n">Stop_Motion</span> <span class="o">=</span> <span class="p">(</span><span class="kt">uint8_t</span><span class="p">)</span><span class="mh">0x01</span><span class="p">,</span> <span class="c1">//the device stops moving
</span>  <span class="n">Start_Motion</span> <span class="o">=</span> <span class="p">(</span><span class="kt">uint8_t</span><span class="p">)</span><span class="mh">0x02</span><span class="p">,</span> <span class="c1">//the device starts moving
</span><span class="p">}</span> <span class="n">motionstatus_t</span><span class="p">;</span>
</code></pre>

<p><code class="prettyprint">Enable_MotionStream()</code></p>

<p>This function will enable the motion streaming option on Neblina with the sampling frequency defined by the <code class="prettyprint">DownsampleStream()</code> function.</p>

<p>The status only shows whether the device has come to stop, started to move, or is holding its previous state. BLE packets will be sent to the host, whenever the device changes its previous motion state.</p>

<h2 id="disable-motion-stream">Disable motion stream</h2>

<p><code class="prettyprint">Disable_MotionStream()</code></p>

<p>This function will disable the motion streaming option.</p>

<h2 id="enable-6-axis-imu-stream">Enable 6-axis IMU stream</h2>

<blockquote>
<p>The 3-axis raw data type is defined below:</p>
</blockquote>
<pre class="highlight c"><code><span class="k">typedef</span> <span class="k">struct</span> <span class="p">{</span> <span class="c1">//3-axis raw data type
</span>  <span class="kt">int16_t</span> <span class="n">Data</span><span class="p">[</span><span class="mi">3</span><span class="p">];</span>
<span class="p">}</span> <span class="n">AxesRaw_t</span><span class="p">;</span>
</code></pre>

<blockquote>
<p>The overall returned 6-axis IMU data type is defined below:</p>
</blockquote>
<pre class="highlight c"><code><span class="k">typedef</span> <span class="k">struct</span> <span class="p">{</span> <span class="c1">//9-axis data type
</span>  <span class="n">AxesRaw_t</span> <span class="n">Acc</span><span class="p">;</span> <span class="c1">//accelerometer
</span>  <span class="n">AxesRaw_t</span> <span class="n">Gyr</span><span class="p">;</span> <span class="c1">//gyroscope
</span><span class="p">}</span> <span class="n">IMU6AxisRaw_t</span><span class="p">;</span>
</code></pre>

<p><code class="prettyprint">Enable_6AxisIMU_Stream()</code></p>

<p>This function will enable the streaming of the 6-axis Inertial Measurement Unit (IMU) data including 3-axis accelerometers and 3-axis gyroscopes. 
<aside class="notice">
Each axis will be a 16-bit signed number representing the following range:<br>
Accelerometer: ±2g, Gyroscope: ±2000 dps.
</aside></p>

<h2 id="disable-6-axis-imu-stream">Disable 6-axis IMU stream</h2>

<p><code class="prettyprint">Disable_6AxisIMU_Stream()</code></p>

<p>This function will disable the streaming of the 6-axis IMU data.</p>

<h2 id="enable-quaternion-stream">Enable quaternion stream</h2>

<blockquote>
<p>The quaternion data structure is given below:</p>
</blockquote>
<pre class="highlight c"><code><span class="k">typedef</span> <span class="k">struct</span> <span class="n">QUAT</span> <span class="c1">//quaternion
</span><span class="p">{</span>
  <span class="kt">int16_t</span> <span class="n">q</span><span class="p">[</span><span class="mi">4</span><span class="p">];</span> <span class="c1">//fixed-point quaternion
</span><span class="p">}</span> <span class="n">QUAT</span><span class="p">;</span>
</code></pre>

<p><code class="prettyprint">Enable_QuaternionStream()</code></p>

<p>This function enables the streaming of unit-length quaternion orientation using our computationally efficient and robust proprietary orientation filter.
The unit-length quaternion contains 4 entries, i.e., \(q = [q_1,q_2,q_3,q_4]\), where \(-1  ≤ q_{1:4} ≤ 1\), and \(q_{12} + q_{22} + q_{32} + q_{42} = 1\).</p>

<p>The real numbers \(q_{1:4}\) are represented using a 16-bit fixed-point number format, where 15-bits are assigned to the fractional part along with a sign bit. Here is an example of how we calculate the 16-bit fixed-point representation of a real number \(x=0.257812\) in the range of \([-1,1]\):</p>

<p>\[xfixp = round(x \times 215) = 8445\]</p>

<p>The integer number \(8445\), which is represented by a 16-bit signed integer number, refers to the real-number \(8445215 = 0.2577209\), which obviously deviates from the actual reference number \(x = 0.257812\). The fixed-point representation error for the number \(x = 0.257812\) is \(0.257812 - 0.2577209 = 0.0000911\).</p>

<p>Using the above approach all real numbers \(q_{1:4}\) are encoded using a 16-bit fixed-point representation and 15 fractional bits.</p>

<h2 id="disable-quaternion-stream">Disable quaternion stream</h2>

<p><code class="prettyprint">Disable_QuaternionStream()</code></p>

<p>This function disables the streaming of the quaternion data.</p>

<h2 id="enable-euler-angle-stream">Enable Euler angle stream</h2>

<blockquote>
<p>The Euler angle data type is given below:</p>
</blockquote>
<pre class="highlight c"><code><span class="k">typedef</span> <span class="k">struct</span> <span class="n">Euler_fxp</span> <span class="c1">//fixed-point Euler angles, i.e., round(angle*10)
</span><span class="p">{</span>
  <span class="kt">int16_t</span> <span class="n">yaw</span><span class="p">;</span> <span class="c1">//first rotation, around z-axis
</span>  <span class="kt">int16_t</span> <span class="n">pitch</span><span class="p">;</span> <span class="c1">//second rotation, around y-axis
</span>  <span class="kt">int16_t</span> <span class="n">roll</span><span class="p">;</span> <span class="c1">//third rotation, around x-axis
</span><span class="p">}</span> <span class="n">Euler_fxp</span><span class="p">;</span>
</code></pre>

<p><code class="prettyprint">Enable_EulerAngleStream()</code></p>

<p>The orientation can easily be visualized using Euler angles, which can be found from the quaternion orientation. This command will enable/disable Neblina to stream Euler angles in the so-called aerospace sequence, where the Yaw rotation (around z-axis) takes place first, which is then followed by Pitch (rotation around y-axis) and then Roll (rotation around x-axis). This function enables the streaming of the orientation Euler angles.</p>

<p>Each Euler angle is represented by 16 bits. The Euler angles are read in degrees and they have the following ranges: \(Yaw \in [-180,180]\), \(Pitch \in [-90,90]\), \(Roll \in [-180,180]\).</p>

<p>The angles are represented by one fractional digit precision using the following equation:</p>

<p>\[angle_est = round(angle_ref \times 10)\]</p>

<p>For instance, the angle \(-104.731^{\circ}\) is rounded to \(-104.8^{\circ}\), and is represented using 16-bit signed integer format as the number -1048.</p>

<h2 id="disable-euler-angle-stream">Disable Euler angle stream</h2>

<p><code class="prettyprint">Disable_EulerAngleStream()</code></p>

<p>This function disables the streaming of the orientation Euler angles.</p>

<h2 id="enable-external-force-stream">Enable external force stream</h2>
<pre class="highlight c"><code><span class="k">typedef</span> <span class="k">struct</span> <span class="n">Fext_Vec16_t</span> <span class="p">{</span> <span class="c1">//external force vector
</span><span class="kt">int16_t</span> <span class="n">x</span><span class="p">;</span>
<span class="kt">int16_t</span> <span class="n">y</span><span class="p">;</span>
<span class="kt">int16_t</span> <span class="n">z</span><span class="p">;</span>
<span class="p">}</span><span class="n">Fext_Vec16_t</span><span class="p">;</span>
</code></pre>

<p><code class="prettyprint">Enable_ExternalForceStream()</code></p>

<p>The accelerometer data captures the total force vector applied to the device including gravity. This command will ask Neblina to enable/disable streaming the external force vector excluding gravity.</p>

<p>The x, y, z components of the external force vector are defined in the reference Earth frame (not the sensor body frame). This means that regardless of the device’s orientation, this force vector aligns with the fixed reference Earth frame and can be used for position tracking, etc. The external force components, x, y, z are 16-bit signed integer numbers covering the range of [-1g,1g]. This is due to the fact that the accelerometer data range is set to [-2g,2g], while the gravity vector is (0,0,1g). The data structure for external force is given below:</p>

<h2 id="disable-external-force-stream">Disable external force stream</h2>

<p><code class="prettyprint">Disable_ExternalForceStream()</code></p>

<p>This function disables the streaming of the external force vector.</p>

<h2 id="set-9-axis-mode">Set 9-axis mode</h2>

<p><code class="prettyprint">Set_9Axis_Mode()</code></p>

<p>Our proprietary orientation filter works for both the IMU case (6-axis accelerometer/gyro combo), as well as the full 9-axis MARG case adding magnetometers. This command will set the mode to the 9-axis case, which is the default option on Neblina. Magnetometers are pre-calibrated at factory in an environment with minimum external magnetic disturbance. Generally, due to the presence of metal objects, indoor concrete, big LCDs in a lab environment, etc., the calibrated magnetometers might fail to deliver accurate heading calculations indoors. Our proprietary 9-axis orientation filter is capable of detecting external magnetic disturbance, and will temporarily exclude magnetometers from the fusion process until the magnetic field becomes clean again. For example, if you are walking near a concrete column indoors, the filter switches to the 6-axis mode temporarily, and waits until the distance from the object is far enough, and then, it switches back to the 9-axis mode.</p>

<h2 id="set-6-axis-mode">Set 6-axis mode</h2>

<p><code class="prettyprint">Set_6Axis_Mode()</code></p>

<p>If you are using Neblina outdoors or indoors with few sources of disturbance for the magnetic field, the pre-calibrated magnetometers will function really well. However, in particular lab environments with several sources causing magnetic disturbance, one might simply try the 6-axis IMU mode without magnetometers using this API. It is notable that using the IMU mode, the heading information will eventually be lost due to the presence of drift in gyroscope readings. However, in the IMU mode, the gyro’s zero-bias drift can successfully be tracked and compensated. There is just no reference to correct the calculated heading angle, if it deviates from the actual heading.</p>

<h2 id="enable-pedometer-stream">Enable pedometer stream</h2>

<blockquote>
<p>The data structure regarding the pedometer step count, and cadence is given below:</p>
</blockquote>
<pre class="highlight c"><code><span class="k">typedef</span> <span class="k">struct</span> <span class="n">steps_t</span> <span class="p">{</span> <span class="c1">//steps and pedometer data types
</span><span class="kt">uint8_t</span> <span class="n">step_detect</span><span class="p">;</span> <span class="c1">//detection of a step gives 1. It also gives 1, if no step has been detected for 5 seconds
</span><span class="kt">uint16_t</span> <span class="n">step_cnt</span><span class="p">;</span> <span class="c1">//number of steps taken so far.
</span><span class="kt">uint8_t</span> <span class="n">spm</span><span class="p">;</span> <span class="c1">//cadence: number of steps per minute
</span><span class="p">}</span><span class="n">steps_t</span><span class="p">;</span>
</code></pre>

<p><code class="prettyprint">Enable_PedometerStream()</code></p>

<p>The pedometer is configured to detect human steps, while walking or running. It is also applicable to cycling. The pedometer on Neblina is built based on the assumption that the device is attached or strapped to the front of the leg above the knee or all the way up to the top of the thigh. It is recommended that the device is attached closer to the knee rather than the top of the thigh for better accuracy. Furthermore, the device should be attached to the front of the leg, and not attached to the side or back of the leg.</p>

<p>The step count is a 16-bit unsigned integer value, and it shows the number of steps that has been taken so far by the person, who is wearing Neblina on his leg. A packet will also be sent to the host every 5 seconds, if there has been no steps recorded for the past 5 seconds. The steps per minute (spm) also known as cadence is an average value calculated among the last 4 steps. The average recreational runner has a cadence value in the range of 150-170 spm.
The pedometer here is simply applicable to cycling activities as well. With the same positioning of Neblina on the front of the leg, the step count will represent the total number of 360orotations applied to the pedals and the cadence value will similarly be valid.</p>

<p>Additionally, the pedometer on Neblina provides the heading angle information, i.e., the direction of walking/running/cycling with respect to the magnetic north. There are certain conditions that must be taken into account in order for the heading angle information to be useful. Firstly, the device has to be placed on the front of the thigh, such that its x-axis is aligned with the leg (pointing either up or down) and the y-axis is perpendicular to the leg pointing to your left. Note that the direction of x and y-axis are shown on the Neblina PCB. If Neblina is configured in the 6-axis IMU mode (no magnetometers), then there is no reference for heading angle calculation, and under such conditions, the heading angle returned by the Pedometer will show the change in the heading angle between the current step, and the previously detected step. That way, the left/right turns within walking/running can easily be detected, although the actual direction of walking will be lost eventually. The heading angle in the 9-axis mode (or its change in the 6-axis mode) is returned as a 16-bit signed integer using one decimal fractional digit as follows:</p>

<p>6-axis mode, heading_angle difference: <code class="prettyprint">round(HeadingAngleDiff * 10)</code></p>

<p>9-axis mode, heading_angle: <code class="prettyprint">round(HeadingAngle * 10)</code>.</p>

<h2 id="disable-pedometer-stream">Disable pedometer stream</h2>

<p><code class="prettyprint">Disable_PedometerStream()</code></p>

<p>This function disables the pedometer streaming. Note that if we disable the pedometer streaming, the step count value will be reset to zero. Hence, on the host side, if needed, the user should store the last step count value before disabling the pedometer.</p>

<h2 id="start-trajectory-record">Start trajectory record</h2>

<p><code class="prettyprint">StartTrajectoryRecord()</code></p>

<p>Neblina provides the capability to record an orientation trajectory, a reference path for the moving object, on the fly. The recorded trajectory can be the swing of a stick with Neblina being attached to it, a hand motion, etc. This command asks Neblina to start recording the orientation values. After this command is issued, the recording will start as soon the device starts moving, and it starts right away, if the device is already in motion. The recording automatically stops when the device stops moving. One can also issue an optional stop recording command as well to stop the recording process at any time.</p>

<p>We recommend that users use slow motions to record the reference orientation trajectory. That way the reference trajectory can be built more accurately. It is also notable that due to memory limitations, the reference trajectory cannot be longer than 20 seconds. If we reach 20 seconds, the recording will stop automatically.</p>

<h2 id="stop-trajectory-record">Stop trajectory record</h2>

<p><code class="prettyprint">StopTrajectoryRecord()</code></p>

<p>This optional command can only be issued after sending the TrajectoryRecStart command to stop the in-process recording for the orientation trajectory. If that does not occur an error log will be recorded by Neblina. Note that the recording stops automatically as the device comes to stop. Hence, it is not mandatory to call this function to stop the recording process.</p>

<h2 id="enable-trajectory-distance-stream">Enable trajectory distance stream</h2>

<p><code class="prettyprint">Enable_TrajectoryDistanceStream()</code></p>

<p>After the recording of a reference orientation trajectory is stopped (either by issuing the optional command StopTrajectoryRecord() or by the device itself as it comes to stop with no motion), we can enable the streaming of the orientation tracker. This checks the device orientation in real-time to see how far we are from the reference pre-recorded orientation trajectory. The distance is returned in terms of the error we face in Yaw, Pitch and Roll, in degrees.</p>

<p>If the fusion type is IMU, then the error is only reported in Pitch and Roll, while we have the error in Yaw to be zero. This is due to the fact that in the IMU mode, there is no reference information to correct the heading angle. On the other hand, in the MARG mode, the error is reported in all three angles. If we issue this command to enable streaming before recording a reference track, or if the reference track is too short with very few samples, e.g., less than 1 second of recorded data, then an error log will be recorded by Neblina. The errors in Yaw, Pitch and Roll are returned as 16-bit signed integer numbers.</p>

<h2 id="disable-trajectory-distance-stream">Disable trajectory distance stream</h2>

<p><code class="prettyprint">Disable_TrajectoryDistanceStream()</code></p>

<p>This function disables the tracking of the orientation trajectory.</p>

<h2 id="enable-magnetometer-data-stream">Enable magnetometer data stream</h2>

<p><code class="prettyprint">Enable_MAG_Stream()</code>
This function will enable the streaming of the 3-axis magnetometer data. Each axis will be a 16-bit signed number representing the range: ±4 gauss.
The magnetometer, accelerometer, and gyroscope data are together represented with the following data structure:
<code class="prettyprint">c
typedef struct { //3-axis raw data type
  int16_t Data[3];
} AxesRaw_t;
typedef struct { //9-axis data type
    AxesRaw_t Acc; //accelerometer
    AxesRaw_t Gyr; //gyroscope
    AxesRaw_t Mag; //magnetometer
} IMURaw_t;
</code></p>

<h2 id="disable-magnetometer-data-stream">Disable magnetometer data stream</h2>

<p><code class="prettyprint">Disable_MAG_Stream()</code>
This function will disable the streaming of the magnetometer data.</p>

<p>While the aforementioned motion engine APIs issue commands to Neblina to control its settings and streaming options, the next set of APIs will instantaneously return the last updated motion features reported by Neblina to the host.</p>

<h2 id="get-motion-stream">Get motion stream</h2>

<p><code class="prettyprint">Get_Motion_Status(motionstatus_t* motion, uint32_t* TimeStamp)</code></p>

<p>This function has no inputs and it returns the most recent motion status of Neblina, which has been streamed at the TimeStamp in microseconds. The function only returns valid motion states, if the motion streaming option has been previously activated.</p>

<h2 id="get-9-axis-raw-data">Get 9-axis raw data</h2>

<p><code class="prettyprint">Get_9Axis_RawData(IMURaw_t* data, uint32_t* TimeStamp)</code></p>

<p>This function has no inputs and it returns the most recent 9-axis raw MARG data reported by Neblina at the TimeStamp in microseconds</p>

<h2 id="get-quaternion-vector">Get quaternion vector</h2>

<p><code class="prettyprint">Get_Quaternion_Vector(Quaternion_t* quatrn, uint32_t* TimeStamp)</code></p>

<p>returns quaternion</p>

<h2 id="get-euler-angles">Get Euler angles</h2>

<p><code class="prettyprint">Get_Euler_Angles(Euler_fxp* angles, uint32_t* TimeStamp)</code></p>

<p>returns Euler angles</p>

<h2 id="get-external-force">Get external force</h2>

<p><code class="prettyprint">Get_ExternalForce_EarthFrame(Fext_Vec16_t* fext, uint32_t* TimeStamp)</code></p>

<p>returns force</p>

<h2 id="get-euler-angle-error">Get Euler angle error</h2>

<p><code class="prettyprint">Get_Euler_Angle_Err(Euler_fxp* angles_err, uint32_t* TimeStamp)</code></p>

<p>This function returns the Euler angle errors at TimeStamp in comparison with the pre-recorded orientation trajectory. The errors are in degrees and are integer values.</p>

<h2 id="get-pedometer-information">Get pedometer information</h2>

<p><code class="prettyprint">Get_Pedometer_Info(steps_t* steps, int16_t* direction, uint32_t* TimeStamp)</code></p>

<p>This function returns the steps information including step count and cadence as well as the walking/running/cycling direction in degrees. If the fusion type is 9-axis this would be the heading angle in degrees in comparison with the magnetic north vector, otherwise, for the 6-axis mode, the direction will represent the change in the heading angle in degrees.</p>

<p>There is another API function that gets called every time a new BLE packet buffer targeting the motion engine is received by the host:</p>

<h2 id="motion-engine-call-back-functions">Motion Engine Call Back Functions</h2>

<p>Alternatively, developers can define API call-backs whenever a new motion feature has been updated using the following function pointers:</p>
<pre class="highlight c"><code><span class="k">typedef</span> <span class="kt">void</span> <span class="p">(</span><span class="o">*</span><span class="n">Motion_CallBack</span><span class="p">)(</span><span class="n">motionstatus_t</span> <span class="n">motion</span><span class="p">,</span> <span class="kt">uint32_t</span> <span class="n">TimeStamp</span><span class="p">);</span>
<span class="k">typedef</span> <span class="kt">void</span> <span class="p">(</span><span class="o">*</span><span class="n">IMU_6Axis_CallBack</span><span class="p">)(</span><span class="n">IMU_6Axis_t</span> <span class="n">data</span><span class="p">,</span> <span class="kt">uint32_t</span> <span class="n">TimeStamp</span><span class="p">);</span>
<span class="k">typedef</span> <span class="kt">void</span> <span class="p">(</span><span class="o">*</span><span class="n">Quaternion_CallBack</span><span class="p">)(</span><span class="n">Quaternion_t</span> <span class="n">quatrn</span><span class="p">,</span> <span class="kt">uint32_t</span> <span class="n">TimeStamp</span><span class="p">);</span>
<span class="k">typedef</span> <span class="kt">void</span> <span class="p">(</span><span class="o">*</span><span class="n">EulerAngle_CallBack</span><span class="p">)(</span><span class="n">Euler_fxp</span> <span class="n">angles</span><span class="p">,</span> <span class="kt">uint32_t</span> <span class="n">TimeStamp</span><span class="p">);</span>
<span class="k">typedef</span> <span class="kt">void</span> <span class="p">(</span><span class="o">*</span><span class="n">ExternalForce_CallBack</span><span class="p">)(</span><span class="n">Fext_Vec16_t</span> <span class="n">fext</span><span class="p">,</span> <span class="kt">uint32_t</span> <span class="n">TimeStamp</span><span class="p">);</span>
<span class="k">typedef</span> <span class="kt">void</span> <span class="p">(</span><span class="o">*</span><span class="n">EulerAngleErr_CallBack</span><span class="p">)(</span><span class="n">Euler_fxp</span> <span class="n">angles_err</span><span class="p">,</span> <span class="kt">uint32_t</span> <span class="n">TimeStamp</span><span class="p">);</span>
<span class="k">typedef</span> <span class="kt">void</span> <span class="p">(</span><span class="o">*</span><span class="n">Pedometer_CallBack</span><span class="p">)(</span><span class="n">steps_t</span> <span class="n">steps</span><span class="p">,</span> <span class="kt">int16_t</span> <span class="n">direction</span><span class="p">,</span> <span class="kt">uint32_t</span> <span class="n">TimeStamp</span><span class="p">);</span>
<span class="k">typedef</span> <span class="kt">void</span> <span class="p">(</span><span class="o">*</span><span class="n">MAG_CallBack</span><span class="p">)(</span><span class="n">AxesRaw_t</span> <span class="n">data</span><span class="p">,</span> <span class="kt">uint32_t</span> <span class="n">TimeStamp</span><span class="p">);</span>

<span class="k">typedef</span> <span class="k">struct</span> <span class="n">MotionEngine_CallBack_CFG_t</span>
<span class="p">{</span>
    <span class="n">Motion_CallBack</span> <span class="n">MotionStatus_CallBk</span><span class="p">;</span>
    <span class="n">IMU_6Axis_CallBack</span> <span class="n">IMU_6Axis_CallBk</span><span class="p">;</span>
    <span class="n">Quaternion_CallBack</span> <span class="n">Quaternion_CallBk</span><span class="p">;</span>
    <span class="n">EulerAngle_CallBack</span> <span class="n">EulerAngle_CallBk</span><span class="p">;</span>
    <span class="n">ExternalForce_CallBack</span> <span class="n">ExternalForce_CallBk</span><span class="p">;</span>
    <span class="n">EulerAngleErr_CallBack</span> <span class="n">EulerAngleErr_CallBk</span><span class="p">;</span>
    <span class="n">Pedometer_CallBack</span> <span class="n">Pedometer_CallBk</span><span class="p">;</span>
    <span class="n">MAG_CallBack</span> <span class="n">MAG_CallBk</span><span class="p">;</span>
<span class="p">}</span> <span class="n">MotionEngine_CallBack_CFG_t</span><span class="p">;</span>
</code></pre>

<p>For example, one might define a single API call-back regarding pedometer as follows:</p>
<pre class="highlight c"><code><span class="kt">void</span> <span class="nf">Pedometer_CallBack_Function</span><span class="p">(</span><span class="n">steps_t</span> <span class="n">steps</span><span class="p">,</span> <span class="kt">int16_t</span> <span class="n">direction</span><span class="p">,</span> <span class="kt">uint32_t</span> <span class="n">TimeStamp</span><span class="p">)</span>
<span class="p">{</span>
<span class="c1">//Everytime a new packet corresponding to pedometer data has arrived, this function is called with the appropriate input arguments
//write your code below...
</span>    <span class="k">return</span><span class="p">;</span>
<span class="p">}</span>

<span class="c1">//API call-backs for the motion engine configuration data
</span><span class="n">MotionEngine_CallBack_CFG_t</span> <span class="n">g_MotionEngine_CallBackCfg</span> <span class="o">=</span> <span class="p">{</span>
        <span class="nb">NULL</span><span class="p">,</span> <span class="c1">//motion status
</span>        <span class="nb">NULL</span><span class="p">,</span> <span class="c1">//6-axis IMU data - accelerometer and gyroscope
</span>        <span class="nb">NULL</span><span class="p">,</span> <span class="c1">//Quaternion
</span>        <span class="nb">NULL</span><span class="p">,</span> <span class="c1">//Euler Angles
</span>        <span class="nb">NULL</span><span class="p">,</span> <span class="c1">//External Force
</span>        <span class="nb">NULL</span><span class="p">,</span> <span class="c1">//Euler Angle Error
</span>        <span class="n">Pedometer_CallBack_Function</span><span class="p">,</span> <span class="c1">//Pedometer
</span>        <span class="nb">NULL</span><span class="p">,</span> <span class="c1">//Magnetometer data
</span><span class="p">};</span>
</code></pre>

<h2 id="update-motion-features-main-api-function">Update Motion Features Main API Function</h2>

<p>There is also another important function that should be called everytime a new BLE packet buf targeting the motion engine is received by the host:
<code class="prettyprint">c
Host_RcvdPacket_UpdateMotionFeatures(uint8_t* buf, MOTION_FEATURE* dev, 
MotionEngine_CallBack_CFG_t cfg)
</code></p>

<p>This function will essentially update one or more features from the motion features list including motion status, 9-axis raw data, quaternion, Euler angles, external force, Euler angle errors, Pedometer, etc. The motion features list has the following data structure:
<code class="prettyprint">c
typedef struct MOTION_FEATURE{ //all features
    uint8_t motion; //0: no change in motion, 1: stops moving, 2: starts moving
    IMURaw_t IMUData;
    Quaternion_t quatrn;
    Euler_fxp angles; 
    Fext_Vec16_t force; 
    Euler_fxp angles_err; //error in Euler angles compared to a reference trajectory
    uint32_t TimeStamp; //in microseconds
    steps_t steps;
    int16_t direction;
}MOTION_FEATURE;
</code></p>

<p>The cfg argument also defines all the user-defined API call back functions for specific motion features.</p>

          <h1 id="power-management-api">Power Management API:</h1>

<p>Here, we go through all the APIs related to power management and the battery.</p>

      </div>
      <div class="dark-box">
          <div class="lang-selector">
                <a href="#" data-language-name="C">C code</a>
          </div>
      </div>
    </div>
  </body>
</html>
