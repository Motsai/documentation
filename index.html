<!doctype html>
<html>
  <head>
    <meta charset="utf-8">
    <meta content="IE=edge,chrome=1" http-equiv="X-UA-Compatible">
    <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
    <title>Neblina API Reference</title>

    <link href="stylesheets/screen.css" rel="stylesheet" type="text/css" media="screen" />
    <link href="stylesheets/print.css" rel="stylesheet" type="text/css" media="print" />
    <script src="https://ajax.googleapis.com/ajax/libs/jquery/2.1.3/jquery.min.js"></script>
      <script src="javascripts/all.js" type="text/javascript"></script>

      <script>
        $(function() {
          setupLanguages(["C","swift","java"]);
        });
      </script>

    <script type="text/javascript" src="http://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML">
    </script>
  </head>

  <body class="index">
    <a href="#" id="nav-button">
      <span>
        NAV
        <img src="images/navbar.png" />
      </span>
    </a>
    <div class="tocify-wrapper">
     <a href="http://www.motsai.com">
      <img src="images/logo.png" />
     </a>
        <div class="lang-selector">
              <a href="#" data-language-name="C">C code</a>
              <a href="#" data-language-name="swift">Swift</a>
              <a href="#" data-language-name="java">Java</a>
        </div>
        <div class="search">
          <input type="text" class="search" id="input-search" placeholder="Search">
        </div>
        <ul class="search-results"></ul>
      <div id="toc">
      </div>
        <ul class="toc-footer">
            <li><a href='http://www.motsai.com'>&copy; Motsai.</a> All Rights Reserved</li>
            <li><a href='http://github.com/tripit/slate'>Documentation Powered by Slate</a></li>
        </ul>
    </div>
    <div class="page-wrapper">
      <div class="dark-box"></div>
      <div class="content">
        <h1 id="introduction">Introduction</h1>

<p>The developers can issue commands to Neblina through the BLE interface and ask for a variety of information by calling the appropriate API functions. The host application makes use of these high-level API functions to ask Neblina to stream different types of data through the BLE interface. By default all streaming features are disabled. We can also request the status of the subsystems on Neblina to check if there has been an invalid command issued in the past by the host. This document explains how developers can make use of these API functions.</p>

<p>Two main subsystems are defined on Neblina: the motion engine and the power management subsystem. All the API functions related to the motion engine are summarized in the <code class="prettyprint">motion_engine_api.h</code> file, while the power management APIs are addressed in the <code class="prettyprint">power_api.h</code> file. The data structures associated with the motion engine and power management APIs are addressed in two files: <code class="prettyprint">neblina.h</code> and <code class="prettyprint">FusionEngineDataTypes.h</code>.</p>

          <h1 id="motion-engine-api">Motion Engine API</h1>

<h2 id="down-sample-stream">Down sample stream</h2>

<p><code class="prettyprint">DownsampleStream(uint16_t n)</code></p>

<p>This function sets the streaming frequency divider. The streaming base frequency is 1KHz, and this function will set the frequency to 1000/n Hz. Currently, the default value of <code class="prettyprint">n</code> is 20 and the acceptable values for <code class="prettyprint">n</code> are integer multiples of 20, i.e., n = 20, 40, 60, etc. If n is set to another value, Neblina will log this as an error. The host can issue commands to request for the error logs as well, which will be explained later.</p>

<h2 id="enable-motion-stream">Enable motion stream</h2>

<blockquote>
<p>The motion status has the following type, which will be streamed:</p>
</blockquote>
<pre class="highlight c"><code><span class="k">typedef</span> <span class="k">enum</span> <span class="p">{</span>
  <span class="n">No_Change</span> <span class="o">=</span> <span class="p">(</span><span class="kt">uint8_t</span><span class="p">)</span><span class="mh">0x00</span><span class="p">,</span> <span class="c1">//holds its previous state
</span>  <span class="n">Stop_Motion</span> <span class="o">=</span> <span class="p">(</span><span class="kt">uint8_t</span><span class="p">)</span><span class="mh">0x01</span><span class="p">,</span> <span class="c1">//the device stops moving
</span>  <span class="n">Start_Motion</span> <span class="o">=</span> <span class="p">(</span><span class="kt">uint8_t</span><span class="p">)</span><span class="mh">0x02</span><span class="p">,</span> <span class="c1">//the device starts moving
</span><span class="p">}</span> <span class="n">motionstatus_t</span><span class="p">;</span>
</code></pre>

<p><code class="prettyprint">EnableMotionStream()</code></p>

<p>This function will enable the motion streaming option on Neblina with the sampling frequency defined by the <code class="prettyprint">DownsampleStream()</code> function.</p>

<p>The status only shows whether the device has come to stop, started to move, or is holding its previous state. BLE packets will be sent to the host, whenever the device changes its previous motion state.</p>

<h2 id="disable-motion-stream">Disable motion stream</h2>

<p><code class="prettyprint">DisableMotionStream()</code></p>

<p>This function will disable the motion streaming option.</p>

<h2 id="enable-6-axis-imu-stream">Enable 6-axis IMU stream</h2>

<blockquote>
<p>The 3-axis raw data type is defined below:</p>
</blockquote>
<pre class="highlight c"><code><span class="k">typedef</span> <span class="k">struct</span> <span class="p">{</span> <span class="c1">//3-axis raw data type
</span>  <span class="kt">int16_t</span> <span class="n">Data</span><span class="p">[</span><span class="mi">3</span><span class="p">];</span>
<span class="p">}</span> <span class="n">AxesRaw_t</span><span class="p">;</span>
</code></pre>

<blockquote>
<p>The overall returned 6-axis IMU data type is defined below:</p>
</blockquote>
<pre class="highlight c"><code><span class="k">typedef</span> <span class="k">struct</span> <span class="p">{</span> <span class="c1">//9-axis data type
</span>  <span class="n">AxesRaw_t</span> <span class="n">Acc</span><span class="p">;</span> <span class="c1">//accelerometer
</span>  <span class="n">AxesRaw_t</span> <span class="n">Gyr</span><span class="p">;</span> <span class="c1">//gyroscope
</span><span class="p">}</span> <span class="n">IMU6AxisRaw_t</span><span class="p">;</span>
</code></pre>

<p><code class="prettyprint">EnableSixAxisIMUStream()</code></p>

<p>This function will enable the streaming of the 6-axis Inertial Measurement Unit (IMU) data including 3-axis accelerometers and 3-axis gyroscopes.
<aside class="notice">
Each axis will be a 16-bit signed number representing the following range:<br>
Accelerometer: ±2g, Gyroscope: ±2000 dps.
</aside></p>

<h2 id="disable-6-axis-imu-stream">Disable 6-axis IMU stream</h2>

<p><code class="prettyprint">DisableSixAxisIMUStream()</code></p>

<p>This function will disable the streaming of the 6-axis IMU data.</p>

<h2 id="enable-quaternion-stream">Enable quaternion stream</h2>

<blockquote>
<p>The quaternion data structure is given below:</p>
</blockquote>
<pre class="highlight c"><code><span class="k">typedef</span> <span class="k">struct</span> <span class="n">QUAT</span> <span class="c1">//quaternion
</span><span class="p">{</span>
  <span class="kt">int16_t</span> <span class="n">q</span><span class="p">[</span><span class="mi">4</span><span class="p">];</span> <span class="c1">//fixed-point quaternion
</span><span class="p">}</span> <span class="n">QUAT</span><span class="p">;</span>
</code></pre>

<p><code class="prettyprint">EnableQuaternionStream()</code></p>

<p>This function enables the streaming of unit-length quaternion orientation using our computationally efficient and robust proprietary orientation filter.
The unit-length quaternion contains 4 entries, i.e., \(q = [q_1,q_2,q_3,q_4]\), where \(-1  ≤ q_{1:4} ≤ 1\), and \(q_{12} + q_{22} + q_{32} + q_{42} = 1\).</p>

<p>The real numbers \(q_{1:4}\) are represented using a 16-bit fixed-point number format, where 15-bits are assigned to the fractional part along with a sign bit. Here is an example of how we calculate the 16-bit fixed-point representation of a real number \(x=0.257812\) in the range of \([-1,1]\):</p>

<p>\[xfixp = round(x \times 215) = 8445\]</p>

<p>The integer number \(8445\), which is represented by a 16-bit signed integer number, refers to the real-number \(8445215 = 0.2577209\), which obviously deviates from the actual reference number \(x = 0.257812\). The fixed-point representation error for the number \(x = 0.257812\) is \(0.257812 - 0.2577209 = 0.0000911\).</p>

<p>Using the above approach all real numbers \(q_{1:4}\) are encoded using a 16-bit fixed-point representation and 15 fractional bits.</p>

<h2 id="disable-quaternion-stream">Disable quaternion stream</h2>

<p><code class="prettyprint">DisableQuaternionStream()</code></p>

<p>This function disables the streaming of the quaternion data.</p>

<h2 id="enable-euler-angle-stream">Enable Euler angle stream</h2>

<blockquote>
<p>The Euler angle data type is given below:</p>
</blockquote>
<pre class="highlight c"><code><span class="k">typedef</span> <span class="k">struct</span> <span class="n">Euler_fxp</span> <span class="c1">//fixed-point Euler angles, i.e., round(angle*10)
</span><span class="p">{</span>
  <span class="kt">int16_t</span> <span class="n">yaw</span><span class="p">;</span> <span class="c1">//first rotation, around z-axis
</span>  <span class="kt">int16_t</span> <span class="n">pitch</span><span class="p">;</span> <span class="c1">//second rotation, around y-axis
</span>  <span class="kt">int16_t</span> <span class="n">roll</span><span class="p">;</span> <span class="c1">//third rotation, around x-axis
</span><span class="p">}</span> <span class="n">Euler_fxp</span><span class="p">;</span>
</code></pre>

<p><code class="prettyprint">EnableEulerAngleStream()</code></p>

<p>The orientation can easily be visualized using Euler angles, which can be found from the quaternion orientation. This command will enable/disable Neblina to stream Euler angles in the so-called aerospace sequence, where the Yaw rotation (around z-axis) takes place first, which is then followed by Pitch (rotation around y-axis) and then Roll (rotation around x-axis). This function enables the streaming of the orientation Euler angles.</p>

<p>Each Euler angle is represented by 16 bits. The Euler angles are read in degrees and they have the following ranges: \(Yaw \in [-180,180]\), \(Pitch \in [-90,90]\), \(Roll \in [-180,180]\).</p>

<p>The angles are represented by one fractional digit precision using the following equation:</p>

<p>\[angle_est = round(angle_ref \times 10)\]</p>

<p>For instance, the angle \(-104.731^{\circ}\) is rounded to \(-104.8^{\circ}\), and is represented using 16-bit signed integer format as the number -1048.</p>

<h2 id="disable-euler-angle-stream">Disable Euler angle stream</h2>

<p><code class="prettyprint">DisableEulerAngleStream()</code></p>

<p>This function disables the streaming of the orientation Euler angles.</p>

<h2 id="enable-external-force-stream">Enable external force stream</h2>
<pre class="highlight c"><code><span class="k">typedef</span> <span class="k">struct</span> <span class="n">Fext_Vec16_t</span> <span class="p">{</span> <span class="c1">//external force vector
</span><span class="kt">int16_t</span> <span class="n">x</span><span class="p">;</span>
<span class="kt">int16_t</span> <span class="n">y</span><span class="p">;</span>
<span class="kt">int16_t</span> <span class="n">z</span><span class="p">;</span>
<span class="p">}</span><span class="n">Fext_Vec16_t</span><span class="p">;</span>
</code></pre>

<p><code class="prettyprint">EnableExternalForceStream()</code></p>

<p>The accelerometer data captures the total force vector applied to the device including gravity. This command will ask Neblina to enable/disable streaming the external force vector excluding gravity.</p>

<p>The x, y, z components of the external force vector are defined in the reference Earth frame (not the sensor body frame). This means that regardless of the device’s orientation, this force vector aligns with the fixed reference Earth frame and can be used for position tracking, etc. The external force components, x, y, z are 16-bit signed integer numbers covering the range of [-1g,1g]. This is due to the fact that the accelerometer data range is set to [-2g,2g], while the gravity vector is (0,0,1g). The data structure for external force is given below:</p>

<h2 id="disable-external-force-stream">Disable external force stream</h2>

<p><code class="prettyprint">DisableExternalForceStream()</code></p>

<p>This function disables the streaming of the external force vector.</p>

<h2 id="set-9-axis-mode">Set 9-axis mode</h2>

<p><code class="prettyprint">SetNineAxisMode()</code></p>

<p>Our proprietary orientation filter works for both the IMU case (6-axis accelerometer/gyro combo), as well as the full 9-axis MARG case adding magnetometers. This command will set the mode to the 9-axis case, which is the default option on Neblina. Magnetometers are pre-calibrated at factory in an environment with minimum external magnetic disturbance. Generally, due to the presence of metal objects, indoor concrete, big LCDs in a lab environment, etc., the calibrated magnetometers might fail to deliver accurate heading calculations indoors. Our proprietary 9-axis orientation filter is capable of detecting external magnetic disturbance, and will temporarily exclude magnetometers from the fusion process until the magnetic field becomes clean again. For example, if you are walking near a concrete column indoors, the filter switches to the 6-axis mode temporarily, and waits until the distance from the object is far enough, and then, it switches back to the 9-axis mode.</p>

<h2 id="set-6-axis-mode">Set 6-axis mode</h2>

<p><code class="prettyprint">SetSixAxisMode()</code></p>

<p>If you are using Neblina outdoors or indoors with few sources of disturbance for the magnetic field, the pre-calibrated magnetometers will function really well. However, in particular lab environments with several sources causing magnetic disturbance, one might simply try the 6-axis IMU mode without magnetometers using this API. It is notable that using the IMU mode, the heading information will eventually be lost due to the presence of drift in gyroscope readings. However, in the IMU mode, the gyro’s zero-bias drift can successfully be tracked and compensated. There is just no reference to correct the calculated heading angle, if it deviates from the actual heading.</p>

<h2 id="enable-pedometer-stream">Enable pedometer stream</h2>

<blockquote>
<p>The data structure regarding the pedometer step count, and cadence is given below:</p>
</blockquote>
<pre class="highlight c"><code><span class="k">typedef</span> <span class="k">struct</span> <span class="n">steps_t</span> <span class="p">{</span> <span class="c1">//steps and pedometer data types
</span><span class="kt">uint8_t</span> <span class="n">step_detect</span><span class="p">;</span> <span class="c1">//detection of a step gives 1. It also gives 1, if no step has been detected for 5 seconds
</span><span class="kt">uint16_t</span> <span class="n">step_cnt</span><span class="p">;</span> <span class="c1">//number of steps taken so far.
</span><span class="kt">uint8_t</span> <span class="n">spm</span><span class="p">;</span> <span class="c1">//cadence: number of steps per minute
</span><span class="p">}</span><span class="n">steps_t</span><span class="p">;</span>
</code></pre>

<p><code class="prettyprint">EnablePedometerStream()</code></p>

<p>The pedometer is configured to detect human steps, while walking or running. It is also applicable to cycling. The pedometer on Neblina is built based on the assumption that the device is attached or strapped to the front of the leg above the knee or all the way up to the top of the thigh. It is recommended that the device is attached closer to the knee rather than the top of the thigh for better accuracy. Furthermore, the device should be attached to the front of the leg, and not attached to the side or back of the leg.</p>

<p>The step count is a 16-bit unsigned integer value, and it shows the number of steps that has been taken so far by the person, who is wearing Neblina on his leg. A packet will also be sent to the host every 5 seconds, if there has been no steps recorded for the past 5 seconds. The steps per minute (spm) also known as cadence is an average value calculated among the last 4 steps. The average recreational runner has a cadence value in the range of 150-170 spm.
The pedometer here is simply applicable to cycling activities as well. With the same positioning of Neblina on the front of the leg, the step count will represent the total number of 360orotations applied to the pedals and the cadence value will similarly be valid.</p>

<p>Additionally, the pedometer on Neblina provides the heading angle information, i.e., the direction of walking/running/cycling with respect to the magnetic north. There are certain conditions that must be taken into account in order for the heading angle information to be useful. Firstly, the device has to be placed on the front of the thigh, such that its x-axis is aligned with the leg (pointing either up or down) and the y-axis is perpendicular to the leg pointing to your left. Note that the direction of x and y-axis are shown on the Neblina PCB. If Neblina is configured in the 6-axis IMU mode (no magnetometers), then there is no reference for heading angle calculation, and under such conditions, the heading angle returned by the Pedometer will show the change in the heading angle between the current step, and the previously detected step. That way, the left/right turns within walking/running can easily be detected, although the actual direction of walking will be lost eventually. The heading angle in the 9-axis mode (or its change in the 6-axis mode) is returned as a 16-bit signed integer using one decimal fractional digit as follows:</p>

<p>6-axis mode, heading_angle difference: <code class="prettyprint">round(HeadingAngleDiff * 10)</code></p>

<p>9-axis mode, heading_angle: <code class="prettyprint">round(HeadingAngle * 10)</code>.</p>

<h2 id="disable-pedometer-stream">Disable pedometer stream</h2>

<p><code class="prettyprint">DisablePedometerStream()</code></p>

<p>This function disables the pedometer streaming. Note that if we disable the pedometer streaming, the step count value will be reset to zero. Hence, on the host side, if needed, the user should store the last step count value before disabling the pedometer.</p>

<h2 id="start-trajectory-record">Start trajectory record</h2>

<p><code class="prettyprint">StartTrajectoryRecord()</code></p>

<p>Neblina provides the capability to record an orientation trajectory, a reference path for the moving object, on the fly. The recorded trajectory can be the swing of a stick with Neblina being attached to it, a hand motion, etc. This command asks Neblina to start recording the orientation values. After this command is issued, the recording will start as soon the device starts moving, and it starts right away, if the device is already in motion. The recording automatically stops when the device stops moving. One can also issue an optional stop recording command as well to stop the recording process at any time.</p>

<p>We recommend that users use slow motions to record the reference orientation trajectory. That way the reference trajectory can be built more accurately. It is also notable that due to memory limitations, the reference trajectory cannot be longer than 20 seconds. If we reach 20 seconds, the recording will stop automatically.</p>

<h2 id="stop-trajectory-record">Stop trajectory record</h2>

<p><code class="prettyprint">StopTrajectoryRecord()</code></p>

<p>This optional command can only be issued after sending the TrajectoryRecStart command to stop the in-process recording for the orientation trajectory. If that does not occur an error log will be recorded by Neblina. Note that the recording stops automatically as the device comes to stop. Hence, it is not mandatory to call this function to stop the recording process.</p>

<h2 id="enable-trajectory-distance-stream">Enable trajectory distance stream</h2>

<p><code class="prettyprint">EnableTrajectoryDistanceStream()</code></p>

<p>After the recording of a reference orientation trajectory is stopped (either by issuing the optional command StopTrajectoryRecord() or by the device itself as it comes to stop with no motion), we can enable the streaming of the orientation tracker. This checks the device orientation in real-time to see how far we are from the reference pre-recorded orientation trajectory. The distance is returned in terms of the error we face in Yaw, Pitch and Roll, in degrees.</p>

<p>If the fusion type is IMU, then the error is only reported in Pitch and Roll, while we have the error in Yaw to be zero. This is due to the fact that in the IMU mode, there is no reference information to correct the heading angle. On the other hand, in the MARG mode, the error is reported in all three angles. If we issue this command to enable streaming before recording a reference track, or if the reference track is too short with very few samples, e.g., less than 1 second of recorded data, then an error log will be recorded by Neblina. The errors in Yaw, Pitch and Roll are returned as 16-bit signed integer numbers.</p>

<h2 id="disable-trajectory-distance-stream">Disable trajectory distance stream</h2>

<p><code class="prettyprint">DisableTrajectoryDistanceStream()</code></p>

<p>This function disables the tracking of the orientation trajectory.</p>

<h2 id="enable-magnetometer-data-stream">Enable magnetometer data stream</h2>

<p><code class="prettyprint">EnableMAGStream()</code></p>

<p>This function will enable the streaming of the 3-axis magnetometer data. Each axis will be a 16-bit signed number representing the range: ±4 gauss.
The magnetometer, accelerometer, and gyroscope data are together represented with the following data structure:</p>
<pre class="highlight c"><code><span class="k">typedef</span> <span class="k">struct</span> <span class="p">{</span> <span class="c1">//3-axis raw data type
</span>  <span class="kt">int16_t</span> <span class="n">Data</span><span class="p">[</span><span class="mi">3</span><span class="p">];</span>
<span class="p">}</span> <span class="n">AxesRaw_t</span><span class="p">;</span>
<span class="k">typedef</span> <span class="k">struct</span> <span class="p">{</span> <span class="c1">//9-axis data type
</span>    <span class="n">AxesRaw_t</span> <span class="n">Acc</span><span class="p">;</span> <span class="c1">//accelerometer
</span>    <span class="n">AxesRaw_t</span> <span class="n">Gyr</span><span class="p">;</span> <span class="c1">//gyroscope
</span>    <span class="n">AxesRaw_t</span> <span class="n">Mag</span><span class="p">;</span> <span class="c1">//magnetometer
</span><span class="p">}</span> <span class="n">IMURaw_t</span><span class="p">;</span>
</code></pre>

<h2 id="disable-magnetometer-data-stream">Disable magnetometer data stream</h2>

<p><code class="prettyprint">DisableMAGStream()</code>
This function will disable the streaming of the magnetometer data.</p>

<p>While the aforementioned motion engine APIs issue commands to Neblina to control its settings and streaming options, the next set of APIs will instantaneously return the last updated motion features reported by Neblina to the host.</p>

<h2 id="get-motion-stream">Get motion stream</h2>

<p><code class="prettyprint">GetMotionStatus(motionstatus_t* motion, uint32_t* TimeStamp)</code></p>

<p>This function has no inputs and it returns the most recent motion status of Neblina, which has been streamed at the TimeStamp in microseconds. The function only returns valid motion states, if the motion streaming option has been previously activated.</p>

<h2 id="get-9-axis-raw-data">Get 9-axis raw data</h2>

<p><code class="prettyprint">GetNineAxisRawData(IMURaw_t* data, uint32_t* TimeStamp)</code></p>

<p>This function has no inputs and it returns the most recent 9-axis raw MARG data reported by Neblina at the TimeStamp in microseconds</p>

<h2 id="get-quaternion-vector">Get quaternion vector</h2>

<p><code class="prettyprint">GetQuaternionVector(Quaternion_t* quatrn, uint32_t* TimeStamp)</code></p>

<p>returns quaternion</p>

<h2 id="get-euler-angles">Get Euler angles</h2>

<p><code class="prettyprint">GetEulerAngles(Euler_fxp* angles, uint32_t* TimeStamp)</code></p>

<p>returns Euler angles</p>

<h2 id="get-external-force">Get external force</h2>

<p><code class="prettyprint">GetExternalForceEarthFrame(Fext_Vec16_t* fext, uint32_t* TimeStamp)</code></p>

<p>returns force</p>

<h2 id="get-euler-angle-error">Get Euler angle error</h2>

<p><code class="prettyprint">GetEulerAngleErr(Euler_fxp* angles_err, uint32_t* TimeStamp)</code></p>

<p>This function returns the Euler angle errors at TimeStamp in comparison with the pre-recorded orientation trajectory. The errors are in degrees and are integer values.</p>

<h2 id="get-pedometer-information">Get pedometer information</h2>

<p><code class="prettyprint">GetPedometerInfo(steps_t* steps, int16_t* direction, uint32_t* TimeStamp)</code></p>

<p>This function returns the steps information including step count and cadence as well as the walking/running/cycling direction in degrees. If the fusion type is 9-axis this would be the heading angle in degrees in comparison with the magnetic north vector, otherwise, for the 6-axis mode, the direction will represent the change in the heading angle in degrees.</p>

<p>There is another API function that gets called every time a new BLE packet buffer targeting the motion engine is received by the host:</p>

<h2 id="motion-engine-call-back-functions">Motion Engine Call Back Functions</h2>

<p>Alternatively, developers can define API call-backs whenever a new motion feature has been updated using the following function pointers:</p>
<pre class="highlight c"><code><span class="k">typedef</span> <span class="kt">void</span> <span class="p">(</span><span class="o">*</span><span class="n">Motion_CallBack</span><span class="p">)(</span><span class="n">motionstatus_t</span> <span class="n">motion</span><span class="p">,</span> <span class="kt">uint32_t</span> <span class="n">TimeStamp</span><span class="p">);</span>
<span class="k">typedef</span> <span class="kt">void</span> <span class="p">(</span><span class="o">*</span><span class="n">IMU_6Axis_CallBack</span><span class="p">)(</span><span class="n">IMU_6Axis_t</span> <span class="n">data</span><span class="p">,</span> <span class="kt">uint32_t</span> <span class="n">TimeStamp</span><span class="p">);</span>
<span class="k">typedef</span> <span class="kt">void</span> <span class="p">(</span><span class="o">*</span><span class="n">Quaternion_CallBack</span><span class="p">)(</span><span class="n">Quaternion_t</span> <span class="n">quatrn</span><span class="p">,</span> <span class="kt">uint32_t</span> <span class="n">TimeStamp</span><span class="p">);</span>
<span class="k">typedef</span> <span class="kt">void</span> <span class="p">(</span><span class="o">*</span><span class="n">EulerAngle_CallBack</span><span class="p">)(</span><span class="n">Euler_fxp</span> <span class="n">angles</span><span class="p">,</span> <span class="kt">uint32_t</span> <span class="n">TimeStamp</span><span class="p">);</span>
<span class="k">typedef</span> <span class="kt">void</span> <span class="p">(</span><span class="o">*</span><span class="n">ExternalForce_CallBack</span><span class="p">)(</span><span class="n">Fext_Vec16_t</span> <span class="n">fext</span><span class="p">,</span> <span class="kt">uint32_t</span> <span class="n">TimeStamp</span><span class="p">);</span>
<span class="k">typedef</span> <span class="kt">void</span> <span class="p">(</span><span class="o">*</span><span class="n">EulerAngleErr_CallBack</span><span class="p">)(</span><span class="n">Euler_fxp</span> <span class="n">angles_err</span><span class="p">,</span> <span class="kt">uint32_t</span> <span class="n">TimeStamp</span><span class="p">);</span>
<span class="k">typedef</span> <span class="kt">void</span> <span class="p">(</span><span class="o">*</span><span class="n">Pedometer_CallBack</span><span class="p">)(</span><span class="n">steps_t</span> <span class="n">steps</span><span class="p">,</span> <span class="kt">int16_t</span> <span class="n">direction</span><span class="p">,</span> <span class="kt">uint32_t</span> <span class="n">TimeStamp</span><span class="p">);</span>
<span class="k">typedef</span> <span class="kt">void</span> <span class="p">(</span><span class="o">*</span><span class="n">MAG_CallBack</span><span class="p">)(</span><span class="n">AxesRaw_t</span> <span class="n">data</span><span class="p">,</span> <span class="kt">uint32_t</span> <span class="n">TimeStamp</span><span class="p">);</span>

<span class="k">typedef</span> <span class="k">struct</span> <span class="n">MotionEngine_CallBack_CFG_t</span>
<span class="p">{</span>
    <span class="n">Motion_CallBack</span> <span class="n">MotionStatus_CallBk</span><span class="p">;</span>
    <span class="n">IMU_6Axis_CallBack</span> <span class="n">IMU_6Axis_CallBk</span><span class="p">;</span>
    <span class="n">Quaternion_CallBack</span> <span class="n">Quaternion_CallBk</span><span class="p">;</span>
    <span class="n">EulerAngle_CallBack</span> <span class="n">EulerAngle_CallBk</span><span class="p">;</span>
    <span class="n">ExternalForce_CallBack</span> <span class="n">ExternalForce_CallBk</span><span class="p">;</span>
    <span class="n">EulerAngleErr_CallBack</span> <span class="n">EulerAngleErr_CallBk</span><span class="p">;</span>
    <span class="n">Pedometer_CallBack</span> <span class="n">Pedometer_CallBk</span><span class="p">;</span>
    <span class="n">MAG_CallBack</span> <span class="n">MAG_CallBk</span><span class="p">;</span>
<span class="p">}</span> <span class="n">MotionEngine_CallBack_CFG_t</span><span class="p">;</span>
</code></pre>

<blockquote>
<p>For example, one might define a single API call-back regarding pedometer as follows:</p>
</blockquote>
<pre class="highlight c"><code><span class="kt">void</span> <span class="nf">PedometerCallBackFunction</span><span class="p">(</span><span class="n">steps_t</span> <span class="n">steps</span><span class="p">,</span> <span class="kt">int16_t</span> <span class="n">direction</span><span class="p">,</span> <span class="kt">uint32_t</span> <span class="n">TimeStamp</span><span class="p">)</span>
<span class="p">{</span>
<span class="c1">//Everytime a new packet corresponding to pedometer data has arrived, this function is called with the appropriate input arguments
//write your code below...
</span>    <span class="k">return</span><span class="p">;</span>
<span class="p">}</span>

<span class="c1">//API call-backs for the motion engine configuration data
</span><span class="n">MotionEngine_CallBack_CFG_t</span> <span class="n">g_MotionEngine_CallBackCfg</span> <span class="o">=</span> <span class="p">{</span>
        <span class="nb">NULL</span><span class="p">,</span> <span class="c1">//motion status
</span>        <span class="nb">NULL</span><span class="p">,</span> <span class="c1">//6-axis IMU data - accelerometer and gyroscope
</span>        <span class="nb">NULL</span><span class="p">,</span> <span class="c1">//Quaternion
</span>        <span class="nb">NULL</span><span class="p">,</span> <span class="c1">//Euler Angles
</span>        <span class="nb">NULL</span><span class="p">,</span> <span class="c1">//External Force
</span>        <span class="nb">NULL</span><span class="p">,</span> <span class="c1">//Euler Angle Error
</span>        <span class="n">PedometerCallBackFunction</span><span class="p">,</span> <span class="c1">//Pedometer
</span>        <span class="nb">NULL</span><span class="p">,</span> <span class="c1">//Magnetometer data
</span><span class="p">};</span>
</code></pre>

<h2 id="update-motion-features-main-api-function">Update Motion Features Main API Function</h2>

<p><code class="prettyprint">
Host_RcvdPacket_UpdateMotionFeatures(uint8_t* buf, MOTION_FEATURE* dev, MotionEngine_CallBack_CFG_t cfg)
</code></p>

<blockquote>
<p>The motion features list has the following data structure:</p>
</blockquote>
<pre class="highlight c"><code><span class="k">typedef</span> <span class="k">struct</span> <span class="n">MOTION_FEATURE</span><span class="p">{</span> <span class="c1">//all features
</span>    <span class="kt">uint8_t</span> <span class="n">motion</span><span class="p">;</span> <span class="c1">//0: no change in motion, 1: stops moving, 2: starts moving
</span>    <span class="n">IMURaw_t</span> <span class="n">IMUData</span><span class="p">;</span>
    <span class="n">Quaternion_t</span> <span class="n">quatrn</span><span class="p">;</span>
    <span class="n">Euler_fxp</span> <span class="n">angles</span><span class="p">;</span>
    <span class="n">Fext_Vec16_t</span> <span class="n">force</span><span class="p">;</span>
    <span class="n">Euler_fxp</span> <span class="n">angles_err</span><span class="p">;</span> <span class="c1">//error in Euler angles compared to a reference trajectory
</span>    <span class="kt">uint32_t</span> <span class="n">TimeStamp</span><span class="p">;</span> <span class="c1">//in microseconds
</span>    <span class="n">steps_t</span> <span class="n">steps</span><span class="p">;</span>
    <span class="kt">int16_t</span> <span class="n">direction</span><span class="p">;</span>
<span class="p">}</span> <span class="n">MOTION_FEATURE</span><span class="p">;</span>
</code></pre>

<p>This is an important function that should be called every time a new BLE packet <code class="prettyprint">buf</code> targeting the motion engine is received by the host.</p>

<p>This function will essentially update one or more features from the motion features list including motion status, 9-axis raw data, quaternion, Euler angles, external force, Euler angle errors, Pedometer, etc.</p>

<p>The <code class="prettyprint">cfg</code> argument defines all the user-defined API call back functions for specific motion features.</p>

          <h1 id="ble-protocol-packet-structure">BLE Protocol - Packet Structure</h1>

<h2 id="general-format">General Format</h2>

<p>The general format of the BLE packets being transferred between Neblina and the host applicaion is as follows:
&lt;!&mdash;
<code class="prettyprint">c
Bytes#1-4: Header Section
Bytes#5-20: Data Section
</code>
&ndash;&gt;
| Bytes 1-4      | Bytes 5-20    |
|&mdash;&mdash;&mdash;&mdash;&mdash;-|&mdash;&mdash;&mdash;&mdash;&mdash;|
| Header Section | Data Section  |</p>

<h3 id="header-section">Header Section</h3>

<p>The header section consists of four bytes.</p>

<table><thead>
<tr>
<th>Byte 1 (bit_7)</th>
<th>Byte 1 (bit_6_0)</th>
<th>Byte 2</th>
<th>Byte 3</th>
<th>Byte 4</th>
</tr>
</thead><tbody>
<tr>
<td>Error Log</td>
<td>Subsystem value</td>
<td>data length</td>
<td>CRC</td>
<td>command</td>
</tr>
</tbody></table>

<h6 id="byte-1-subsystem">Byte#1: Subsystem</h6>
<pre class="highlight c"><code><span class="n">Bit</span><span class="err">#</span><span class="mi">7</span><span class="o">:</span> <span class="p">(</span><span class="n">Error</span> <span class="n">Log</span><span class="p">)</span> 
</code></pre>

<p>If set to 1, it shows that the packet is an error log command/response associated with the subsystem represented by Bits#6-0. Otherwise, if set to 0, it shows that the packet is a regular command/response associated with the subsystem represented by Bits#6-0.
<code class="prettyprint">c 
Bits#6-0: (Subsystem value)
</code>
This is the subsystem index, which currently has only two modes: 0x01 (motion engine), 0x02 (power management)</p>

<h6 id="byte-2-data-section-packet-length">Byte#2: Data Section Packet Length</h6>

<p>The BLE protocol currently is set to a fixed packet length of 20 bytes including both header and data, where the data section is 16 bytes. Hence, this byte is set to the value of 0x10 = 16.</p>

<h6 id="byte-3-crc">Byte#3: CRC</h6>

<p>The 8-bit CRC is calculated over the data section of the packet.</p>

<h6 id="byte-4-command">Byte#4: Command</h6>

<p>Different commands can be issued identified by this field. For the power management subsystem, currently there is only one command as follows:
&ldquo;`c </p>

<h1 id="define-powermgmt_get_bat_level-0">define POWERMGMT_GET_BAT_LEVEL 0</h1>
<pre class="highlight plaintext"><code>However, regarding the motion engine subsystem a number of commands exist, which are listed below:
```c 
#define Downsample 0x01 //Downsampling factor definition
#define MotionState 0x02 //streaming Motion State
#define IMU_Data 0x03 //streaming the 6-axis IMU data
#define Quaternion 0x04 //streaming the quaternion data
#define EulerAngle 0x05 //streaming the Euler angles
#define ExtForce 0x06 //streaming the external force
#define SetFusionType 0x07 //setting the Fusion type to either 6-axis or 9-axis
#define TrajectoryRecStart 0x08 //start recording orientation trajectory
#define TrajectoryRecStop 0x09 //stop recording orientation trajectory
#define TrajectoryDistance 0x0A //calculating the distance from a pre-recorded orientation trajectory
#define Pedometer 0x0B //streaming pedometer data
#define MAG_Data 0x0C //streaming magnetometer data
</code></pre>

<h3 id="data-section">Data Section</h3>

<p>The data section consists of 12 bytes, which could be representing different values depending on the subsystem and the command fields. </p>

<h4 id="power-management-data-section">Power Management Data Section</h4>

<p>Regarding the power management&rsquo;s single command, the data consists of only 2 valid bytes, representing the percentage of the battery level with one decimal fractional digit precision, i.e., an unsigned integer within the range of [0, 1000]:</p>

<h6 id="byte-5-battery-level-least-significant-byte-lsb">Byte#5: battery level (%), Least Significant Byte (LSB)</h6>

<h6 id="byte-6-battery-level-most-significant-byte-msb">Byte#6: battery level (%), Most Significant Byte (MSB)</h6>

<h4 id="motion-engine-data-section">Motion Engine Data Section</h4>

<p>The data section regarding the motion engine has different representations based on the command, which are explained next.</p>

<h5 id="downsample-command">Downsample Command</h5>

<p>Neblina is programmed to stream information to the host as per its request. The maximum streaming frequency is 1kHz, and the users can reduce the streaming frequency to 1000/n, where n is an unsigned 16-bit positive integer. Regarding this command, we have the following data section with only 2 valid bytes:</p>

<h6 id="byte-5-n-lsb">Byte#5: n, LSB</h6>

<h6 id="byte-6-n-msb">Byte#6: n, MSB</h6>

<p>Currently, the supporting streaming frequencies are multiplicands of 20, i.e., 50Hz, 50Hz/2, 50Hz/3, and so on. Therefore, the value of n should be set as a multiplicand of 20. Overall, the downsample command packet including both header and data sections has the following structure:</p>

<table><thead>
<tr>
<th style="text-align: center">Byte 1 (subsystem)</th>
<th style="text-align: center">Byte 2 (length)</th>
<th style="text-align: center">Byte 3 (CRC)</th>
<th style="text-align: center">Byte 4 (command)</th>
<th style="text-align: center">Bytes 5-6</th>
<th style="text-align: center">Bytes 7-20</th>
</tr>
</thead><tbody>
<tr>
<td style="text-align: center">0x01</td>
<td style="text-align: center">0x10</td>
<td style="text-align: center">CRC</td>
<td style="text-align: center">0x01 (downsample)</td>
<td style="text-align: center">factor</td>
<td style="text-align: center">Reserved</td>
</tr>
</tbody></table>

<h5 id="motionstate-command-response">MotionState Command/Response</h5>

<p>In the command mode the packet enables/disables the streaming of the motion state for the target device. If enabled, it basically inquires whether the device changes its motion state either from stop to movement, or from movement to stop. We recommend that after the device power-up you hold the device still for a couple of seconds (2-5 seconds) for initial calibration and orientation convergence. Data section for this packet type is a single byte, which should be set to either 0 or 1 to disable or enable the streaming of the motion states respectively.</p>

<h6 id="byte-5-enable-1-or-disable-0-motion-state-streaming">Byte#5: Enable (1) or Disable (0) Motion State streaming</h6>

<p>Overall, the command packet has the following structure:</p>

<table><thead>
<tr>
<th style="text-align: center">Byte 1 (subsystem)</th>
<th style="text-align: center">Byte 2 (length)</th>
<th style="text-align: center">Byte 3 (CRC)</th>
<th style="text-align: center">Byte 4 (command)</th>
<th style="text-align: center">Byte 5</th>
<th>Bytes 6-20</th>
</tr>
</thead><tbody>
<tr>
<td style="text-align: center">0x01</td>
<td style="text-align: center">0x10</td>
<td style="text-align: center">CRC</td>
<td style="text-align: center">0x02 (motion state)</td>
<td style="text-align: center">Enable/Disable</td>
<td>Reserved</td>
</tr>
</tbody></table>

<p>In the response mode, the data section includes 4 bytes for the timestamp in microseconds (Byte#5-8), and then the motion state data, i.e., a single byte (Byte#9), which is either 0 (stop motion) or 1 (start motion). The whole response packet structure including header is shown below:</p>

<table><thead>
<tr>
<th style="text-align: center">Byte 1 (subsystem)</th>
<th style="text-align: center">Byte 2 (length)</th>
<th style="text-align: center">Byte 3 (CRC)</th>
<th style="text-align: center">Byte 4 (command)</th>
<th style="text-align: center">Byte 5-8</th>
<th>Byte 9</th>
<th>Bytes 10-20</th>
</tr>
</thead><tbody>
<tr>
<td style="text-align: center">0x01</td>
<td style="text-align: center">0x10</td>
<td style="text-align: center">CRC</td>
<td style="text-align: center">0x02</td>
<td style="text-align: center">TimeStamp</td>
<td>stop/start</td>
<td>Reserved</td>
</tr>
</tbody></table>

<h5 id="imu_data-command-response">IMU_Data Command/Response</h5>

<p>In the command mode, the packet enables/disables the streaming of the 6-axis IMU sensor data, including the 3-axis accelerometer and 3-axis gyroscope. Byte#5 will be a Boolean value representing the Enable/Disable command. The overall command mode IMU_Data packet has the following structure:</p>

<table><thead>
<tr>
<th style="text-align: center">Byte 1 (subsystem)</th>
<th style="text-align: center">Byte 2 (length)</th>
<th style="text-align: center">Byte 3 (CRC)</th>
<th style="text-align: center">Byte 4 (command)</th>
<th style="text-align: center">Byte 5</th>
<th>Bytes 6-20</th>
</tr>
</thead><tbody>
<tr>
<td style="text-align: center">0x01</td>
<td style="text-align: center">0x10</td>
<td style="text-align: center">CRC</td>
<td style="text-align: center">0x03 (6-axis IMU)</td>
<td style="text-align: center">Enable/Disable</td>
<td>Reserved</td>
</tr>
</tbody></table>

<p>In the response mode, the data section includes 4 bytes for the timestamp (Byte#5-8), which is then followed by 12 bytes (Byte#9-20) with the &quot;IMU6AxisRaw_t&rdquo; data structure defined in the motion engine documentation. The whole response packet structure including header is shown below:</p>

<table><thead>
<tr>
<th style="text-align: center">Byte 1 (subsystem)</th>
<th style="text-align: center">Byte 2 (length)</th>
<th style="text-align: center">Byte 3 (CRC)</th>
<th style="text-align: center">Byte 4 (command)</th>
<th style="text-align: center">Byte 5-8</th>
<th>Byte 9-20</th>
</tr>
</thead><tbody>
<tr>
<td style="text-align: center">0x01</td>
<td style="text-align: center">0x10</td>
<td style="text-align: center">CRC</td>
<td style="text-align: center">0x03</td>
<td style="text-align: center">TimeStamp</td>
<td>IMU6AxisRaw_t</td>
</tr>
</tbody></table>

<h5 id="quaternion-command-response">Quaternion Command/Response</h5>

<p>In the command mode, the packet enables/disables the streaming of the quaternion data. Byte#5 will be a Boolean value representing the Enable/Disable command. The overall command mode Quaternion packet has the following structure:</p>

<table><thead>
<tr>
<th style="text-align: center">Byte 1 (subsystem)</th>
<th style="text-align: center">Byte 2 (length)</th>
<th style="text-align: center">Byte 3 (CRC)</th>
<th style="text-align: center">Byte 4 (command)</th>
<th style="text-align: center">Byte 5</th>
<th>Bytes 6-20</th>
</tr>
</thead><tbody>
<tr>
<td style="text-align: center">0x01</td>
<td style="text-align: center">0x10</td>
<td style="text-align: center">CRC</td>
<td style="text-align: center">0x04 (Quaternion)</td>
<td style="text-align: center">Enable/Disable</td>
<td>Reserved</td>
</tr>
</tbody></table>

<p>In the response mode, the data section includes 4 bytes for the timestamp (Byte#5-8), which is then followed by 8 bytes (Byte#9-16) with the &ldquo;QUAT&rdquo; data structure defined in the motion engine documentation. The whole response packet structure including header is shown below:</p>

<table><thead>
<tr>
<th style="text-align: center">Byte 1 (subsystem)</th>
<th style="text-align: center">Byte 2 (length)</th>
<th style="text-align: center">Byte 3 (CRC)</th>
<th style="text-align: center">Byte 4 (command)</th>
<th style="text-align: center">Byte 5-8</th>
<th>Byte 9-16</th>
<th>Bytes 17-20</th>
</tr>
</thead><tbody>
<tr>
<td style="text-align: center">0x01</td>
<td style="text-align: center">0x10</td>
<td style="text-align: center">CRC</td>
<td style="text-align: center">0x04</td>
<td style="text-align: center">TimeStamp</td>
<td>IMU6AxisRaw_t</td>
<td>Reserved</td>
</tr>
</tbody></table>

<h5 id="eulerangle-command-response">EulerAngle Command/Response</h5>

<p>In the command mode, the packet enables/disables the streaming of the Euler Angle data. Byte#5 will be a Boolean value representing the Enable/Disable command. The overall command mode Euler Angle packet has the following structure:</p>

<table><thead>
<tr>
<th style="text-align: center">Byte 1 (subsystem)</th>
<th style="text-align: center">Byte 2 (length)</th>
<th style="text-align: center">Byte 3 (CRC)</th>
<th style="text-align: center">Byte 4 (command)</th>
<th style="text-align: center">Byte 5</th>
<th>Bytes 6-20</th>
</tr>
</thead><tbody>
<tr>
<td style="text-align: center">0x01</td>
<td style="text-align: center">0x10</td>
<td style="text-align: center">CRC</td>
<td style="text-align: center">0x05 (Euler Angle)</td>
<td style="text-align: center">Enable/Disable</td>
<td>Reserved</td>
</tr>
</tbody></table>

<p>In the response mode, the data section includes 4 bytes for the timestamp (Byte#5-8), which is then followed by 6 bytes (Byte#9-14) with the &ldquo;Euler_fxp&rdquo; data structure defined in the motion engine documentation. The whole response packet structure including header is shown below:</p>

<table><thead>
<tr>
<th style="text-align: center">Byte 1 (subsystem)</th>
<th style="text-align: center">Byte 2 (length)</th>
<th style="text-align: center">Byte 3 (CRC)</th>
<th style="text-align: center">Byte 4 (command)</th>
<th style="text-align: center">Byte 5-8</th>
<th style="text-align: center">Byte 9-14</th>
<th style="text-align: center">Bytes 15-20</th>
</tr>
</thead><tbody>
<tr>
<td style="text-align: center">0x01</td>
<td style="text-align: center">0x10</td>
<td style="text-align: center">CRC</td>
<td style="text-align: center">0x05</td>
<td style="text-align: center">TimeStamp</td>
<td style="text-align: center">Euler_fxp</td>
<td style="text-align: center">Reserved</td>
</tr>
</tbody></table>

<h5 id="extforce-command-response">ExtForce Command/Response</h5>

<p>In the command mode, the packet enables/disables the streaming of the external force vector. Byte#5 will be a Boolean value representing the Enable/Disable command. The overall command mode External Force packet has the following structure:</p>

<table><thead>
<tr>
<th style="text-align: center">Byte 1 (subsystem)</th>
<th style="text-align: center">Byte 2 (length)</th>
<th style="text-align: center">Byte 3 (CRC)</th>
<th style="text-align: center">Byte 4 (command)</th>
<th style="text-align: center">Byte 5</th>
<th>Bytes 6-20</th>
</tr>
</thead><tbody>
<tr>
<td style="text-align: center">0x01</td>
<td style="text-align: center">0x10</td>
<td style="text-align: center">CRC</td>
<td style="text-align: center">0x06 (ExtForce)</td>
<td style="text-align: center">Enable/Disable</td>
<td>Reserved</td>
</tr>
</tbody></table>

<p>In the response mode, the data section includes 4 bytes for the timestamp (Byte#5-8), which is then followed by 6 bytes (Byte#9-14) with the &ldquo;Fext_Vec16_t&rdquo; data structure defined in the motion engine documentation. The whole response packet structure including header is shown below:</p>

<table><thead>
<tr>
<th style="text-align: center">Byte 1 (subsystem)</th>
<th style="text-align: center">Byte 2 (length)</th>
<th style="text-align: center">Byte 3 (CRC)</th>
<th style="text-align: center">Byte 4 (command)</th>
<th style="text-align: center">Byte 5-8</th>
<th>Byte 9-14</th>
<th>Bytes 15-20</th>
</tr>
</thead><tbody>
<tr>
<td style="text-align: center">0x01</td>
<td style="text-align: center">0x10</td>
<td style="text-align: center">CRC</td>
<td style="text-align: center">0x06</td>
<td style="text-align: center">TimeStamp</td>
<td>Fext_Vec16_t</td>
<td>Reserved</td>
</tr>
</tbody></table>

<h5 id="setfusiontype-command">SetFusionType Command:</h5>

<p>The corresponding packet includes only 1 byte, indicating whether the fusion should be set to either 6-axis IMU or 9-axis MARG mode involving magnetometers:</p>

<h6 id="byte-5-6-axis-imu-mode-0-or-9-axis-marg-mode-1">Byte#5: 6-axis IMU mode (0) or 9-axis MARG mode (1)</h6>

<p>The overall packet structure is as follows:</p>

<table><thead>
<tr>
<th style="text-align: center">Byte 1 (subsystem)</th>
<th style="text-align: center">Byte 2 (length)</th>
<th style="text-align: center">Byte 3 (CRC)</th>
<th style="text-align: center">Byte 4 (command)</th>
<th style="text-align: center">Byte 5</th>
<th>Bytes 6-20</th>
</tr>
</thead><tbody>
<tr>
<td style="text-align: center">0x01</td>
<td style="text-align: center">0x10</td>
<td style="text-align: center">CRC</td>
<td style="text-align: center">0x07 (SetFusionType)</td>
<td style="text-align: center">IMU/MARG</td>
<td>Reserved</td>
</tr>
</tbody></table>

<h5 id="trajectoryrecstart-amp-trajectoryrecstop">TrajectoryRecStart &amp; TrajectoryRecStop</h5>

<p>These two commands do not have a data section.</p>

<h5 id="trajectorydistance-command-response">TrajectoryDistance Command/Response</h5>

<p>In the command mode, the packet enables/disables the streaming of the distance from a pre-recorded orientation trajectory. Byte#5 will be a Boolean value representing the Enable/Disable command. The overall command mode TrajectoryDistance packet has the following structure:</p>

<table><thead>
<tr>
<th style="text-align: center">Byte 1 (subsystem)</th>
<th style="text-align: center">Byte 2 (length)</th>
<th style="text-align: center">Byte 3 (CRC)</th>
<th style="text-align: center">Byte 4 (command)</th>
<th style="text-align: center">Byte 5</th>
<th>Bytes 6-20</th>
</tr>
</thead><tbody>
<tr>
<td style="text-align: center">0x01</td>
<td style="text-align: center">0x10</td>
<td style="text-align: center">CRC</td>
<td style="text-align: center">0x0A (Trajectory)</td>
<td style="text-align: center">Enable/Disable</td>
<td>Reserved</td>
</tr>
</tbody></table>

<p>In the response mode, the data section includes 4 bytes for the timestamp (Byte#5-8), which is then followed by 6 bytes (Byte#9-14) representing the Euler angle errors, which have been described by the &ldquo;EnableTrajectoryDistanceStream()&rdquo; API function in the motion engine documentation. The whole response packet structure including header is shown below:</p>

<table><thead>
<tr>
<th style="text-align: center">Byte 1 (subsystem)</th>
<th style="text-align: center">Byte 2 (length)</th>
<th style="text-align: center">Byte 3 (CRC)</th>
<th style="text-align: center">Byte 4 (command)</th>
<th style="text-align: center">Byte 5-8</th>
<th style="text-align: center">Byte 9-14</th>
<th>Bytes 15-20</th>
</tr>
</thead><tbody>
<tr>
<td style="text-align: center">0x01</td>
<td style="text-align: center">0x10</td>
<td style="text-align: center">CRC</td>
<td style="text-align: center">0x0A</td>
<td style="text-align: center">TimeStamp</td>
<td style="text-align: center">EulerAngle Errors</td>
<td>Reserved</td>
</tr>
</tbody></table>

<h5 id="pedometer-command-response">Pedometer Command/Response</h5>

<p>In the command mode, the packet enables/disables the streaming of the Pedometer data. Byte#5 will be a Boolean value representing the Enable/Disable command. The overall command mode Pedometer packet has the following structure:</p>

<table><thead>
<tr>
<th style="text-align: center">Byte 1 (subsystem)</th>
<th style="text-align: center">Byte 2 (length)</th>
<th style="text-align: center">Byte 3 (CRC)</th>
<th style="text-align: center">Byte 4 (command)</th>
<th style="text-align: center">Byte 5</th>
<th>Bytes 6-20</th>
</tr>
</thead><tbody>
<tr>
<td style="text-align: center">0x01</td>
<td style="text-align: center">0x10</td>
<td style="text-align: center">CRC</td>
<td style="text-align: center">0x0B (Pedometer)</td>
<td style="text-align: center">Enable/Disable</td>
<td>Reserved</td>
</tr>
</tbody></table>

<p>In the response mode, the data section includes 4 bytes for the timestamp (Byte#5-8), which is then followed by 5 bytes (Byte#9-13) with the following subfields:</p>

<h6 id="byte-9-step-count-lsb">Byte#9: step count, LSB</h6>

<h6 id="byte-10-step-count-msb">Byte#10: step count, MSB</h6>

<h6 id="byte-11-spm-cadence">Byte#11: spm (Cadence)</h6>

<h6 id="byte-12-walking-direction-angle-value-lsb">Byte#12: walking direction angle value LSB</h6>

<h6 id="byte-13-walking-direction-angle-value-msb">Byte#13: walking direction angle value MSB</h6>

<p>Note that the angle format includes one fractional decimal digit and it is compatible with the Euler angle representations described in the motion engine documentation. The whole response packet structure including header is shown below:</p>

<table><thead>
<tr>
<th style="text-align: center">Byte 1</th>
<th style="text-align: center">Byte 2</th>
<th style="text-align: center">Byte 3</th>
<th style="text-align: center">Byte 4</th>
<th style="text-align: center">Byte 5-8</th>
<th style="text-align: center">Byte 9-10</th>
<th style="text-align: center">Byte 11</th>
<th style="text-align: center">Byte 12-13</th>
<th style="text-align: center">Bytes 14-20</th>
</tr>
</thead><tbody>
<tr>
<td style="text-align: center">0x01</td>
<td style="text-align: center">0x10</td>
<td style="text-align: center">CRC</td>
<td style="text-align: center">0x0B</td>
<td style="text-align: center">TimeStamp</td>
<td style="text-align: center">step count</td>
<td style="text-align: center">cadence</td>
<td style="text-align: center">direction angle</td>
<td style="text-align: center">Reserved</td>
</tr>
</tbody></table>

<h5 id="mag_data-command-response">MAG_Data Command/Response</h5>

<p>In the command mode, the packet enables/disables the streaming of the 3-axis magnetometer data along with the 3-axis accelerometer data. Byte#5 will be a Boolean value representing the Enable/Disable command. The overall command mode MAG_Data packet has the following structure:</p>

<table><thead>
<tr>
<th style="text-align: center">Byte 1 (subsystem)</th>
<th style="text-align: center">Byte 2 (length)</th>
<th style="text-align: center">Byte 3 (CRC)</th>
<th style="text-align: center">Byte 4 (command)</th>
<th style="text-align: center">Byte 5</th>
<th>Bytes 6-20</th>
</tr>
</thead><tbody>
<tr>
<td style="text-align: center">0x01</td>
<td style="text-align: center">0x10</td>
<td style="text-align: center">CRC</td>
<td style="text-align: center">0x0C (MAG_Data)</td>
<td style="text-align: center">Enable/Disable</td>
<td>Reserved</td>
</tr>
</tbody></table>

<p>In the response mode, the data section includes 4 bytes for the timestamp (Byte#5-8), which is then followed by 2*6 bytes (Byte#9-20) with the &ldquo;AxesRaw_t&rdquo; data structure defined in the motion engine documentation. The first 6 bytes (Byte#9-14) will be a &ldquo;AxesRaw_t&rdquo; data structure for magnetometers, and the next 6 bytes (Byte#15-20) will be another &ldquo;AxesRaw_t&rdquo; data structure for accelerometer data. The whole response packet structure including header is shown below:</p>

<table><thead>
<tr>
<th style="text-align: center">Byte 1 (subsystem)</th>
<th style="text-align: center">Byte 2 (length)</th>
<th style="text-align: center">Byte 3 (CRC)</th>
<th style="text-align: center">Byte 4 (command)</th>
<th style="text-align: center">Byte 5-8</th>
<th style="text-align: center">Byte 9-14</th>
<th style="text-align: center">Bytes 15-20</th>
</tr>
</thead><tbody>
<tr>
<td style="text-align: center">0x01</td>
<td style="text-align: center">0x10</td>
<td style="text-align: center">CRC</td>
<td style="text-align: center">0x0C</td>
<td style="text-align: center">TimeStamp</td>
<td style="text-align: center">AxesRaw_t (Mag)</td>
<td style="text-align: center">AxesRaw_t (Acc)</td>
</tr>
</tbody></table>

          <h1 id="power-management-api">Power Management API:</h1>

<p>Here, we go through all the APIs related to power management and the battery.</p>

      </div>
      <div class="dark-box">
          <div class="lang-selector">
                <a href="#" data-language-name="C">C code</a>
                <a href="#" data-language-name="swift">Swift</a>
                <a href="#" data-language-name="java">Java</a>
          </div>
      </div>
    </div>
  </body>
</html>
