<!doctype html>
<html>
  <head>
    <meta charset="utf-8">
    <meta content="IE=edge,chrome=1" http-equiv="X-UA-Compatible">
    <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
    <title>Neblina API Reference</title>

    <link href="stylesheets/screen.css" rel="stylesheet" type="text/css" media="screen" />
    <link href="stylesheets/print.css" rel="stylesheet" type="text/css" media="print" />
    <script src="https://ajax.googleapis.com/ajax/libs/jquery/2.1.3/jquery.min.js"></script>
      <script src="javascripts/all.js" type="text/javascript"></script>

      <script>
        $(function() {
          setupLanguages(["C","swift","java"]);
        });
      </script>

    <script type="text/javascript" src="http://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML">
    </script>
  </head>

  <body class="index">
    <a href="#" id="nav-button">
      <span>
        NAV
        <img src="images/navbar.png" />
      </span>
    </a>
    <div class="tocify-wrapper">
     <a href="http://www.motsai.com">
      <img src="images/logo.png" />
     </a>
        <div class="lang-selector">
              <a href="#" data-language-name="C">C code</a>
              <a href="#" data-language-name="swift">Swift</a>
              <a href="#" data-language-name="java">Java</a>
        </div>
        <div class="search">
          <input type="text" class="search" id="input-search" placeholder="Search">
        </div>
        <ul class="search-results"></ul>
      <div id="toc">
      </div>
        <ul class="toc-footer">
            <li><a href='http://www.motsai.com'>&copy; Motsai.</a> All Rights Reserved</li>
            <li><a href='http://github.com/tripit/slate'>Documentation Powered by Slate</a></li>
        </ul>
    </div>
    <div class="page-wrapper">
      <div class="dark-box"></div>
      <div class="content">
        <h1 id="introduction">Introduction</h1>

<p>The developers can issue commands to Neblina through the BLE interface and ask for a variety of information by calling the appropriate API functions. The host application makes use of these high-level API functions to ask Neblina to stream different types of data through the BLE interface. By default all streaming features are disabled. We can also request the status of the subsystems on Neblina to check if there has been an invalid command issued in the past by the host. This document explains how developers can make use of these API functions.</p>

<p>Two main subsystems are defined on Neblina: the motion engine and the power management subsystem. All the API functions related to the motion engine are summarized in the <code class="prettyprint">motion_engine_api.h</code> file, while the power management APIs are addressed in the <code class="prettyprint">power_api.h</code> file. The data structures associated with the motion engine and power management APIs are addressed in two files: <code class="prettyprint">neblina.h</code> and <code class="prettyprint">FusionEngineDataTypes.h</code>.</p>

          <h1 id="motion-engine-api">Motion Engine API</h1>

<h2 id="down-sample-stream">Down sample stream</h2>

<p><code class="prettyprint">DownsampleStream(uint16_t n)</code></p>

<p>This function sets the streaming frequency divider. The streaming base frequency is 1KHz, and this function will set the frequency to 1000/n Hz. Currently, the default value of <code class="prettyprint">n</code> is 20 and the acceptable values for <code class="prettyprint">n</code> are integer multiples of 20, i.e., n = 20, 40, 60, etc. If n is set to another value, Neblina will log this as an error. The host can issue commands to request for the error logs as well, which will be explained later.</p>

<h2 id="enable-motion-stream">Enable motion stream</h2>

<blockquote>
<p>The motion status has the following type, which will be streamed:</p>
</blockquote>
<pre class="highlight c"><code><span class="k">typedef</span> <span class="k">enum</span> <span class="p">{</span>
  <span class="n">No_Change</span> <span class="o">=</span> <span class="p">(</span><span class="kt">uint8_t</span><span class="p">)</span><span class="mh">0x00</span><span class="p">,</span> <span class="c1">//holds its previous state
</span>  <span class="n">Stop_Motion</span> <span class="o">=</span> <span class="p">(</span><span class="kt">uint8_t</span><span class="p">)</span><span class="mh">0x01</span><span class="p">,</span> <span class="c1">//the device stops moving
</span>  <span class="n">Start_Motion</span> <span class="o">=</span> <span class="p">(</span><span class="kt">uint8_t</span><span class="p">)</span><span class="mh">0x02</span><span class="p">,</span> <span class="c1">//the device starts moving
</span><span class="p">}</span> <span class="n">motionstatus_t</span><span class="p">;</span>
</code></pre>

<p><code class="prettyprint">EnableMotionStream()</code></p>

<p>This function will enable the motion streaming option on Neblina with the sampling frequency defined by the <code class="prettyprint">DownsampleStream()</code> function.</p>

<p>The status only shows whether the device has come to stop, started to move, or is holding its previous state. BLE packets will be sent to the host, whenever the device changes its previous motion state.</p>

<h2 id="disable-motion-stream">Disable motion stream</h2>

<p><code class="prettyprint">DisableMotionStream()</code></p>

<p>This function will disable the motion streaming option.</p>

<h2 id="enable-6-axis-imu-stream">Enable 6-axis IMU stream</h2>

<blockquote>
<p>The 3-axis raw data type is defined below:</p>
</blockquote>
<pre class="highlight c"><code><span class="k">typedef</span> <span class="k">struct</span> <span class="p">{</span> <span class="c1">//3-axis raw data type - 6 bytes
</span>  <span class="kt">int16_t</span> <span class="n">Data</span><span class="p">[</span><span class="mi">3</span><span class="p">];</span>
<span class="p">}</span> <span class="n">AxesRaw_t</span><span class="p">;</span>
</code></pre>

<blockquote>
<p>The overall returned 6-axis IMU data type is defined below:</p>
</blockquote>
<pre class="highlight c"><code><span class="k">typedef</span> <span class="k">struct</span> <span class="p">{</span> <span class="c1">//6-axis data type - 12 bytes
</span>  <span class="n">AxesRaw_t</span> <span class="n">Acc</span><span class="p">;</span> <span class="c1">//accelerometer
</span>  <span class="n">AxesRaw_t</span> <span class="n">Gyr</span><span class="p">;</span> <span class="c1">//gyroscope
</span><span class="p">}</span> <span class="n">IMU6AxisRaw_t</span><span class="p">;</span>
</code></pre>

<p><code class="prettyprint">EnableSixAxisIMUStream()</code></p>

<p>This function will enable the streaming of the 6-axis Inertial Measurement Unit (IMU) data including 3-axis accelerometers and 3-axis gyroscopes.
<aside class="notice">
Each axis will be a 16-bit signed number representing the following range:<br>
Accelerometer: ±2g, Gyroscope: ±2000 dps.
</aside></p>

<h2 id="disable-6-axis-imu-stream">Disable 6-axis IMU stream</h2>

<p><code class="prettyprint">DisableSixAxisIMUStream()</code></p>

<p>This function will disable the streaming of the 6-axis IMU data.</p>

<h2 id="enable-quaternion-stream">Enable quaternion stream</h2>

<blockquote>
<p>The quaternion data structure is given below:</p>
</blockquote>
<pre class="highlight c"><code><span class="k">typedef</span> <span class="k">struct</span> <span class="n">Quaternion_t</span> <span class="c1">//quaternion
</span><span class="p">{</span>
  <span class="kt">int16_t</span> <span class="n">q</span><span class="p">[</span><span class="mi">4</span><span class="p">];</span> <span class="c1">//fixed-point normalized quaternion with 15 fractional bits
</span><span class="p">}</span> <span class="n">Quaternion_t</span><span class="p">;</span>
</code></pre>

<p><code class="prettyprint">EnableQuaternionStream()</code></p>

<p>This function enables the streaming of unit-length quaternion orientation using our computationally efficient and robust proprietary orientation filter.
The unit-length quaternion contains 4 entries, i.e., \(q = [q_1,q_2,q_3,q_4]\), where \(-1  ≤ q_{1:4} ≤ 1\), and \(q_{12} + q_{22} + q_{32} + q_{42} = 1\).</p>

<p>The real numbers \(q_{1:4}\) are represented using a 16-bit fixed-point number format, where 15-bits are assigned to the fractional part along with a sign bit. Here is an example of how we calculate the 16-bit fixed-point representation of a real number \(x=0.257812\) in the range of \([-1,1]\):</p>

<p>\[xfixp = round(x \times 215) = 8445\]</p>

<p>The integer number \(8445\), which is represented by a 16-bit signed integer number, refers to the real-number \(8445215 = 0.2577209\), which obviously deviates from the actual reference number \(x = 0.257812\). The fixed-point representation error for the number \(x = 0.257812\) is \(0.257812 - 0.2577209 = 0.0000911\).</p>

<p>Using the above approach all real numbers \(q_{1:4}\) are encoded using a 16-bit fixed-point representation and 15 fractional bits.</p>

<h2 id="disable-quaternion-stream">Disable quaternion stream</h2>

<p><code class="prettyprint">DisableQuaternionStream()</code></p>

<p>This function disables the streaming of the quaternion data.</p>

<h2 id="enable-euler-angle-stream">Enable Euler angle stream</h2>

<blockquote>
<p>The Euler angle data type is given below:</p>
</blockquote>
<pre class="highlight c"><code><span class="k">typedef</span> <span class="k">struct</span> <span class="n">Euler_fxp_t</span> <span class="c1">//fixed-point Euler angles, i.e., round(angle*10)
</span><span class="p">{</span>
  <span class="kt">int16_t</span> <span class="n">yaw</span><span class="p">;</span> <span class="c1">//first rotation, around z-axis
</span>  <span class="kt">int16_t</span> <span class="n">pitch</span><span class="p">;</span> <span class="c1">//second rotation, around y-axis
</span>  <span class="kt">int16_t</span> <span class="n">roll</span><span class="p">;</span> <span class="c1">//third rotation, around x-axis
</span><span class="p">}</span> <span class="n">Euler_fxp_t</span><span class="p">;</span>
</code></pre>

<p><code class="prettyprint">EnableEulerAngleStream()</code></p>

<p>The orientation can easily be visualized using Euler angles, which can be found from the quaternion orientation. This command will enable/disable Neblina to stream Euler angles in the so-called aerospace sequence, where the Yaw rotation (around z-axis) takes place first, which is then followed by Pitch (rotation around y-axis) and then Roll (rotation around x-axis). This function enables the streaming of the orientation Euler angles.</p>

<p>Each Euler angle is represented by 16 bits. The Euler angles are read in degrees and they have the following ranges: \(Yaw \in [-180,180]\), \(Pitch \in [-90,90]\), \(Roll \in [-180,180]\).</p>

<p>The angles are represented by one fractional digit precision using the following equation:</p>

<p>\[angle_est = round(angle_ref \times 10)\]</p>

<p>For instance, the angle \(-104.731^{\circ}\) is rounded to \(-104.8^{\circ}\), and is represented using 16-bit signed integer format as the number -1048.</p>

<h2 id="disable-euler-angle-stream">Disable Euler angle stream</h2>

<p><code class="prettyprint">DisableEulerAngleStream()</code></p>

<p>This function disables the streaming of the orientation Euler angles.</p>

<h2 id="enable-external-force-stream">Enable external force stream</h2>

<p><code class="prettyprint">EnableExternalForceStream()</code></p>

<p>The accelerometer data captures the total force vector applied to the device including gravity. This command will ask Neblina to enable/disable streaming the external force vector excluding gravity.</p>

<p>The x, y, z components of the external force vector are defined in the reference Earth frame (not the sensor body frame). This means that regardless of the device’s orientation, this force vector aligns with the fixed reference Earth frame and can be used for position tracking, etc. The external force components, x, y, z are 16-bit signed integer numbers covering the range of [-1g,1g]. This is due to the fact that the accelerometer data range is set to [-2g,2g], while the gravity vector is (0,0,1g). The data structure for external force is given below:
<code class="prettyprint">c
typedef struct Fext_Vec16_t { //external force vector
int16_t x;
int16_t y;
int16_t z;
}Fext_Vec16_t;
</code></p>

<h2 id="disable-external-force-stream">Disable external force stream</h2>

<p><code class="prettyprint">DisableExternalForceStream()</code></p>

<p>This function disables the streaming of the external force vector.</p>

<h2 id="set-9-axis-mode">Set 9-axis mode</h2>

<p><code class="prettyprint">SetNineAxisMode()</code></p>

<p>Our proprietary orientation filter works for both the IMU case (6-axis accelerometer/gyro combo), as well as the full 9-axis MARG case adding magnetometers. This command will set the mode to the 9-axis case, which is the default option on Neblina. Magnetometers are pre-calibrated at factory in an environment with minimum external magnetic disturbance. Generally, due to the presence of metal objects, indoor concrete, big LCDs in a lab environment, etc., the calibrated magnetometers might fail to deliver accurate heading calculations indoors. Our proprietary 9-axis orientation filter is capable of detecting external magnetic disturbance, and will temporarily exclude magnetometers from the fusion process until the magnetic field becomes clean again. For example, if you are walking near a concrete column indoors, the filter switches to the 6-axis mode temporarily, and waits until the distance from the object is far enough, and then, it switches back to the 9-axis mode.</p>

<h2 id="set-6-axis-mode">Set 6-axis mode</h2>

<p><code class="prettyprint">SetSixAxisMode()</code></p>

<p>If you are using Neblina outdoors or indoors with few sources of disturbance for the magnetic field, the pre-calibrated magnetometers will function really well. However, in particular lab environments with several sources causing magnetic disturbance, one might simply try the 6-axis IMU mode without magnetometers using this API. It is notable that using the IMU mode, the heading information will eventually be lost due to the presence of drift in gyroscope readings. However, in the IMU mode, the gyro’s zero-bias drift can successfully be tracked and compensated. There is just no reference to correct the calculated heading angle, if it deviates from the actual heading.</p>

<h2 id="enable-pedometer-stream">Enable pedometer stream</h2>

<blockquote>
<p>The data structure regarding the pedometer step count, and cadence is given below:</p>
</blockquote>
<pre class="highlight c"><code><span class="k">typedef</span> <span class="k">struct</span> <span class="n">steps_t</span> <span class="p">{</span> <span class="c1">//steps and pedometer data types
</span><span class="kt">uint8_t</span> <span class="n">step_detect</span><span class="p">;</span> <span class="c1">//detection of a step gives 1. It also gives 1, if no step has been detected for 5 seconds
</span><span class="kt">uint16_t</span> <span class="n">step_cnt</span><span class="p">;</span> <span class="c1">//number of steps taken so far.
</span><span class="kt">uint8_t</span> <span class="n">spm</span><span class="p">;</span> <span class="c1">//cadence: number of steps per minute
</span><span class="p">}</span><span class="n">steps_t</span><span class="p">;</span>
</code></pre>

<p><code class="prettyprint">EnablePedometerStream()</code></p>

<p>The pedometer is configured to detect human steps, while walking or running. It is also applicable to cycling. The pedometer on Neblina is built based on the assumption that the device is attached or strapped to the front of the leg above the knee or all the way up to the top of the thigh. It is recommended that the device is attached closer to the knee rather than the top of the thigh for better accuracy. Furthermore, the device should be attached to the front of the leg, and not attached to the side or back of the leg.</p>

<p>The step count is a 16-bit unsigned integer value, and it shows the number of steps that has been taken so far by the person, who is wearing Neblina on his leg. A packet will also be sent to the host every 5 seconds, if there has been no steps recorded for the past 5 seconds. The steps per minute (spm) also known as cadence is an average value calculated among the last 4 steps. The average recreational runner has a cadence value in the range of 150-170 spm.
The pedometer here is simply applicable to cycling activities as well. With the same positioning of Neblina on the front of the leg, the step count will represent the total number of 360orotations applied to the pedals and the cadence value will similarly be valid.</p>

<p>Additionally, the pedometer on Neblina provides the heading angle information, i.e., the direction of walking/running/cycling with respect to the magnetic north. There are certain conditions that must be taken into account in order for the heading angle information to be useful. Firstly, the device has to be placed on the front of the thigh, such that its x-axis is aligned with the leg (pointing either up or down) and the y-axis is perpendicular to the leg pointing to your left. Note that the direction of x and y-axis are shown on the Neblina PCB. If Neblina is configured in the 6-axis IMU mode (no magnetometers), then there is no reference for heading angle calculation, and under such conditions, the heading angle returned by the Pedometer will show the change in the heading angle between the current step, and the previously detected step. That way, the left/right turns within walking/running can easily be detected, although the actual direction of walking will be lost eventually. The heading angle in the 9-axis mode (or its change in the 6-axis mode) is returned as a 16-bit signed integer using one decimal fractional digit as follows:</p>

<p>6-axis mode, heading_angle difference: <code class="prettyprint">round(HeadingAngleDiff * 10)</code></p>

<p>9-axis mode, heading_angle: <code class="prettyprint">round(HeadingAngle * 10)</code>.</p>

<h2 id="disable-pedometer-stream">Disable pedometer stream</h2>

<p><code class="prettyprint">DisablePedometerStream()</code></p>

<p>This function disables the pedometer streaming. Note that if we disable the pedometer streaming, the step count value will be reset to zero. Hence, on the host side, if needed, the user should store the last step count value before disabling the pedometer.</p>

<h2 id="start-trajectory-record">Start trajectory record</h2>

<p><code class="prettyprint">StartTrajectoryRecord()</code></p>

<p>Neblina provides the capability to record an orientation trajectory, a reference path for the moving object, on the fly. The recorded trajectory can be the swing of a stick with Neblina being attached to it, a hand motion, etc. This command asks Neblina to start recording the orientation values. After this command is issued, the recording will start as soon the device starts moving, and it starts right away, if the device is already in motion. The recording automatically stops when the device stops moving. One can also issue an optional stop recording command as well to stop the recording process at any time.</p>

<p>We recommend that users use slow motions to record the reference orientation trajectory. That way the reference trajectory can be built more accurately. It is also notable that due to memory limitations, the reference trajectory cannot be longer than 20 seconds. If we reach 20 seconds, the recording will stop automatically.</p>

<h2 id="stop-trajectory-record">Stop trajectory record</h2>

<p><code class="prettyprint">StopTrajectoryRecord()</code></p>

<p>This optional command can only be issued after sending the TrajectoryRecStart command to stop the in-process recording for the orientation trajectory. If that does not occur an error log will be recorded by Neblina. Note that the recording stops automatically as the device comes to stop. Hence, it is not mandatory to call this function to stop the recording process.</p>

<h2 id="enable-trajectory-information-stream">Enable trajectory information stream</h2>

<p><code class="prettyprint">EnableTrajectoryInfoStream()</code></p>

<p>After the recording of a reference orientation trajectory is stopped (either by issuing the optional command StopTrajectoryRecord() or by the device itself as it comes to stop with no motion), we can enable the streaming of the orientation tracker. This checks the device orientation in real-time to see how far we are from the reference pre-recorded orientation trajectory. The distance is returned in terms of the error we face in Yaw, Pitch and Roll, in degrees. Furthermore, the device counts how many times the recorded pattern has been repeated. It also captures how much of the track has been covered so far (0% to 100%). Whenever the full trajectory is covered, the counter is increased by 1, and the progress percentage is reset to 0%.</p>

<p>If the fusion type is IMU, then the Euler angle error is only reported in Pitch and Roll, while we have the error in Yaw to be zero. This is due to the fact that in the IMU mode, there is no reference information to correct the heading angle. On the other hand, in the MARG mode, the error is reported in all three angles. If we issue this command to enable streaming before recording a reference track, or if the reference track is too short with very few samples, e.g., less than 1 second of recorded data, then an error log will be recorded by Neblina. The errors in Yaw, Pitch and Roll are returned as 16-bit signed integer numbers.</p>

<h2 id="disable-trajectory-information-stream">Disable trajectory information stream</h2>

<p><code class="prettyprint">DisableTrajectoryInfoStream()</code></p>

<p>This function disables the tracking of the orientation trajectory.</p>

<h2 id="enable-magnetometer-data-stream">Enable magnetometer data stream</h2>

<p><code class="prettyprint">EnableMAGStream()</code></p>

<p>This function will enable the streaming of the 3-axis magnetometer data. Each axis will be a 16-bit signed number representing the range: ±4 gauss.
The 3-axis magnetometer data has the following structure:</p>
<pre class="highlight c"><code><span class="k">typedef</span> <span class="k">struct</span> <span class="p">{</span> <span class="c1">//3-axis raw data type - 6 bytes
</span>  <span class="kt">int16_t</span> <span class="n">Data</span><span class="p">[</span><span class="mi">3</span><span class="p">];</span>
<span class="p">}</span> <span class="n">AxesRaw_t</span><span class="p">;</span>


<span class="cp">## Disable magnetometer data stream
</span>
<span class="err">`</span><span class="n">DisableMAGStream</span><span class="p">()</span><span class="err">`</span>
<span class="n">This</span> <span class="n">function</span> <span class="n">will</span> <span class="n">disable</span> <span class="n">the</span> <span class="n">streaming</span> <span class="n">of</span> <span class="n">the</span> <span class="n">magnetometer</span> <span class="n">data</span><span class="p">.</span>

<span class="n">While</span> <span class="n">the</span> <span class="n">aforementioned</span> <span class="n">motion</span> <span class="n">engine</span> <span class="n">APIs</span> <span class="n">issue</span> <span class="n">commands</span> <span class="n">to</span> <span class="n">Neblina</span> <span class="n">to</span> <span class="n">control</span> <span class="n">its</span> <span class="n">settings</span> <span class="n">and</span> <span class="n">streaming</span> <span class="n">options</span><span class="p">,</span> <span class="n">the</span> <span class="n">next</span> <span class="n">set</span> <span class="n">of</span> <span class="n">APIs</span> <span class="n">will</span> <span class="n">instantaneously</span> <span class="k">return</span> <span class="n">the</span> <span class="n">last</span> <span class="n">updated</span> <span class="n">motion</span> <span class="n">features</span> <span class="n">reported</span> <span class="n">by</span> <span class="n">Neblina</span> <span class="n">to</span> <span class="n">the</span> <span class="n">host</span><span class="p">.</span>

<span class="cp">## Get motion stream
</span>
<span class="err">`</span><span class="n">GetMotionStatus</span><span class="p">(</span><span class="n">motionstatus_t</span><span class="o">*</span> <span class="n">motion</span><span class="p">,</span> <span class="kt">uint32_t</span><span class="o">*</span> <span class="n">TimeStamp</span><span class="p">)</span><span class="err">`</span>

<span class="n">This</span> <span class="n">function</span> <span class="n">has</span> <span class="n">no</span> <span class="n">inputs</span> <span class="n">and</span> <span class="n">it</span> <span class="n">returns</span> <span class="n">the</span> <span class="n">most</span> <span class="n">recent</span> <span class="n">motion</span> <span class="n">status</span> <span class="n">of</span> <span class="n">Neblina</span><span class="p">,</span> <span class="n">which</span> <span class="n">has</span> <span class="n">been</span> <span class="n">streamed</span> <span class="n">at</span> <span class="n">the</span> <span class="n">TimeStamp</span> <span class="n">in</span> <span class="n">microseconds</span><span class="p">.</span> <span class="n">The</span> <span class="n">function</span> <span class="n">only</span> <span class="n">returns</span> <span class="n">valid</span> <span class="n">motion</span> <span class="n">states</span><span class="p">,</span> <span class="k">if</span> <span class="n">the</span> <span class="n">motion</span> <span class="n">streaming</span> <span class="n">option</span> <span class="n">has</span> <span class="n">been</span> <span class="n">previously</span> <span class="n">activated</span><span class="p">.</span>

<span class="cp">## Get 9-axis raw data
</span>
<span class="err">`</span><span class="n">GetNineAxisRawData</span><span class="p">(</span><span class="n">IMURaw_t</span><span class="o">*</span> <span class="n">data</span><span class="p">,</span> <span class="kt">uint32_t</span><span class="o">*</span> <span class="n">TimeStamp</span><span class="p">)</span><span class="err">`</span>

<span class="n">This</span> <span class="n">function</span> <span class="n">has</span> <span class="n">no</span> <span class="n">inputs</span> <span class="n">and</span> <span class="n">it</span> <span class="n">returns</span> <span class="n">the</span> <span class="n">most</span> <span class="n">recent</span> <span class="mi">9</span><span class="o">-</span><span class="n">axis</span> <span class="n">raw</span> <span class="n">MARG</span> <span class="n">data</span> <span class="n">reported</span> <span class="n">by</span> <span class="n">Neblina</span> <span class="n">at</span> <span class="n">the</span> <span class="n">TimeStamp</span> <span class="n">in</span> <span class="n">microseconds</span>

<span class="cp">## Get quaternion vector
</span>
<span class="err">`</span><span class="n">GetQuaternionVector</span><span class="p">(</span><span class="n">Quaternion_t</span><span class="o">*</span> <span class="n">quatrn</span><span class="p">,</span> <span class="kt">uint32_t</span><span class="o">*</span> <span class="n">TimeStamp</span><span class="p">)</span><span class="err">`</span>

<span class="n">returns</span> <span class="n">quaternion</span>

<span class="cp">## Get Euler angles
</span>
<span class="err">`</span><span class="n">GetEulerAngles</span><span class="p">(</span><span class="n">Euler_fxp_t</span><span class="o">*</span> <span class="n">angles</span><span class="p">,</span> <span class="kt">uint32_t</span><span class="o">*</span> <span class="n">TimeStamp</span><span class="p">)</span><span class="err">`</span>

<span class="n">returns</span> <span class="n">Euler</span> <span class="n">angles</span>

<span class="cp">## Get external force
</span>
<span class="err">`</span><span class="n">GetExternalForceEarthFrame</span><span class="p">(</span><span class="n">Fext_Vec16_t</span><span class="o">*</span> <span class="n">fext</span><span class="p">,</span> <span class="kt">uint32_t</span><span class="o">*</span> <span class="n">TimeStamp</span><span class="p">)</span><span class="err">`</span>

<span class="n">returns</span> <span class="n">force</span>

<span class="cp">## Get Euler angle error
</span>
<span class="err">`</span><span class="n">GetEulerAngleErr</span><span class="p">(</span><span class="n">Euler_fxp_t</span><span class="o">*</span> <span class="n">angles_err</span><span class="p">,</span> <span class="kt">uint32_t</span><span class="o">*</span> <span class="n">TimeStamp</span><span class="p">)</span><span class="err">`</span>

<span class="n">This</span> <span class="n">function</span> <span class="n">returns</span> <span class="n">the</span> <span class="n">Euler</span> <span class="n">angle</span> <span class="n">errors</span> <span class="n">at</span> <span class="n">TimeStamp</span> <span class="n">in</span> <span class="n">comparison</span> <span class="n">with</span> <span class="n">the</span> <span class="n">pre</span><span class="o">-</span><span class="n">recorded</span> <span class="n">orientation</span> <span class="n">trajectory</span><span class="p">.</span> <span class="n">The</span> <span class="n">errors</span> <span class="n">are</span> <span class="n">in</span> <span class="n">degrees</span> <span class="n">and</span> <span class="n">are</span> <span class="n">integer</span> <span class="n">values</span><span class="p">.</span>

<span class="cp">## Get pedometer information
</span>
<span class="err">`</span><span class="n">GetPedometerInfo</span><span class="p">(</span><span class="n">steps_t</span><span class="o">*</span> <span class="n">steps</span><span class="p">,</span> <span class="kt">int16_t</span><span class="o">*</span> <span class="n">direction</span><span class="p">,</span> <span class="kt">uint32_t</span><span class="o">*</span> <span class="n">TimeStamp</span><span class="p">)</span><span class="err">`</span>

<span class="n">This</span> <span class="n">function</span> <span class="n">returns</span> <span class="n">the</span> <span class="n">steps</span> <span class="n">information</span> <span class="n">including</span> <span class="n">step</span> <span class="n">count</span> <span class="n">and</span> <span class="n">cadence</span> <span class="n">as</span> <span class="n">well</span> <span class="n">as</span> <span class="n">the</span> <span class="n">walking</span><span class="o">/</span><span class="n">running</span><span class="o">/</span><span class="n">cycling</span> <span class="n">direction</span> <span class="n">in</span> <span class="n">degrees</span><span class="p">.</span> <span class="n">If</span> <span class="n">the</span> <span class="n">fusion</span> <span class="n">type</span> <span class="n">is</span> <span class="mi">9</span><span class="o">-</span><span class="n">axis</span> <span class="n">this</span> <span class="n">would</span> <span class="n">be</span> <span class="n">the</span> <span class="n">heading</span> <span class="n">angle</span> <span class="n">in</span> <span class="n">degrees</span> <span class="n">in</span> <span class="n">comparison</span> <span class="n">with</span> <span class="n">the</span> <span class="n">magnetic</span> <span class="n">north</span> <span class="n">vector</span><span class="p">,</span> <span class="n">otherwise</span><span class="p">,</span> <span class="k">for</span> <span class="n">the</span> <span class="mi">6</span><span class="o">-</span><span class="n">axis</span> <span class="n">mode</span><span class="p">,</span> <span class="n">the</span> <span class="n">direction</span> <span class="n">will</span> <span class="n">represent</span> <span class="n">the</span> <span class="n">change</span> <span class="n">in</span> <span class="n">the</span> <span class="n">heading</span> <span class="n">angle</span> <span class="n">in</span> <span class="n">degrees</span><span class="p">.</span>

<span class="n">There</span> <span class="n">is</span> <span class="n">another</span> <span class="n">API</span> <span class="n">function</span> <span class="n">that</span> <span class="n">gets</span> <span class="n">called</span> <span class="n">every</span> <span class="n">time</span> <span class="n">a</span> <span class="n">new</span> <span class="n">BLE</span> <span class="n">packet</span> <span class="n">buffer</span> <span class="n">targeting</span> <span class="n">the</span> <span class="n">motion</span> <span class="n">engine</span> <span class="n">is</span> <span class="n">received</span> <span class="n">by</span> <span class="n">the</span> <span class="n">host</span><span class="o">:</span>

<span class="cp">## Motion Engine Call Back Functions
</span>
<span class="n">Alternatively</span><span class="p">,</span> <span class="n">developers</span> <span class="n">can</span> <span class="n">define</span> <span class="n">API</span> <span class="n">call</span><span class="o">-</span><span class="n">backs</span> <span class="n">whenever</span> <span class="n">a</span> <span class="n">new</span> <span class="n">motion</span> <span class="n">feature</span> <span class="n">has</span> <span class="n">been</span> <span class="n">updated</span> <span class="n">using</span> <span class="n">the</span> <span class="n">following</span> <span class="n">function</span> <span class="n">pointers</span><span class="o">:</span>

<span class="err">```</span><span class="n">c</span>
<span class="k">typedef</span> <span class="kt">void</span> <span class="p">(</span><span class="o">*</span><span class="n">Motion_CallBack</span><span class="p">)(</span><span class="n">motionstatus_t</span> <span class="n">motion</span><span class="p">,</span> <span class="kt">uint32_t</span> <span class="n">TimeStamp</span><span class="p">);</span>
<span class="k">typedef</span> <span class="kt">void</span> <span class="p">(</span><span class="o">*</span><span class="n">IMU_6Axis_CallBack</span><span class="p">)(</span><span class="n">IMU_6Axis_t</span> <span class="n">data</span><span class="p">,</span> <span class="kt">uint32_t</span> <span class="n">TimeStamp</span><span class="p">);</span>
<span class="k">typedef</span> <span class="kt">void</span> <span class="p">(</span><span class="o">*</span><span class="n">Quaternion_CallBack</span><span class="p">)(</span><span class="n">Quaternion_t</span> <span class="n">quatrn</span><span class="p">,</span> <span class="kt">uint32_t</span> <span class="n">TimeStamp</span><span class="p">);</span>
<span class="k">typedef</span> <span class="kt">void</span> <span class="p">(</span><span class="o">*</span><span class="n">EulerAngle_CallBack</span><span class="p">)(</span><span class="n">Euler_fxp_t</span> <span class="n">angles</span><span class="p">,</span> <span class="kt">uint32_t</span> <span class="n">TimeStamp</span><span class="p">);</span>
<span class="k">typedef</span> <span class="kt">void</span> <span class="p">(</span><span class="o">*</span><span class="n">ExternalForce_CallBack</span><span class="p">)(</span><span class="n">Fext_Vec16_t</span> <span class="n">fext</span><span class="p">,</span> <span class="kt">uint32_t</span> <span class="n">TimeStamp</span><span class="p">);</span>
<span class="k">typedef</span> <span class="kt">void</span> <span class="p">(</span><span class="o">*</span><span class="n">EulerAngleErr_CallBack</span><span class="p">)(</span><span class="n">Euler_fxp_t</span> <span class="n">angles_err</span><span class="p">,</span> <span class="kt">uint32_t</span> <span class="n">TimeStamp</span><span class="p">);</span>
<span class="k">typedef</span> <span class="kt">void</span> <span class="p">(</span><span class="o">*</span><span class="n">Pedometer_CallBack</span><span class="p">)(</span><span class="n">steps_t</span> <span class="n">steps</span><span class="p">,</span> <span class="kt">int16_t</span> <span class="n">direction</span><span class="p">,</span> <span class="kt">uint32_t</span> <span class="n">TimeStamp</span><span class="p">);</span>
<span class="k">typedef</span> <span class="kt">void</span> <span class="p">(</span><span class="o">*</span><span class="n">MAG_CallBack</span><span class="p">)(</span><span class="n">AxesRaw_t</span> <span class="n">data</span><span class="p">,</span> <span class="kt">uint32_t</span> <span class="n">TimeStamp</span><span class="p">);</span>

<span class="k">typedef</span> <span class="k">struct</span> <span class="n">MotionEngine_CallBack_CFG_t</span>
<span class="p">{</span>
    <span class="n">Motion_CallBack</span> <span class="n">MotionStatus_CallBk</span><span class="p">;</span>
    <span class="n">IMU_6Axis_CallBack</span> <span class="n">IMU_6Axis_CallBk</span><span class="p">;</span>
    <span class="n">Quaternion_CallBack</span> <span class="n">Quaternion_CallBk</span><span class="p">;</span>
    <span class="n">EulerAngle_CallBack</span> <span class="n">EulerAngle_CallBk</span><span class="p">;</span>
    <span class="n">ExternalForce_CallBack</span> <span class="n">ExternalForce_CallBk</span><span class="p">;</span>
    <span class="n">EulerAngleErr_CallBack</span> <span class="n">EulerAngleErr_CallBk</span><span class="p">;</span>
    <span class="n">Pedometer_CallBack</span> <span class="n">Pedometer_CallBk</span><span class="p">;</span>
    <span class="n">MAG_CallBack</span> <span class="n">MAG_CallBk</span><span class="p">;</span>
    <span class="n">SitStand_CallBack</span> <span class="n">SitStand_CallBk</span><span class="p">;</span>
<span class="p">}</span> <span class="n">MotionEngine_CallBack_CFG_t</span><span class="p">;</span>
</code></pre>

<blockquote>
<p>For example, one might define a single API call-back regarding pedometer as follows:</p>
</blockquote>
<pre class="highlight c"><code><span class="kt">void</span> <span class="nf">PedometerCallBackFunction</span><span class="p">(</span><span class="n">steps_t</span> <span class="n">steps</span><span class="p">,</span> <span class="kt">int16_t</span> <span class="n">direction</span><span class="p">,</span> <span class="kt">uint32_t</span> <span class="n">TimeStamp</span><span class="p">)</span>
<span class="p">{</span>
<span class="c1">//Everytime a new packet corresponding to pedometer data has arrived, this function is called with the appropriate input arguments
//write your code below...
</span>    <span class="k">return</span><span class="p">;</span>
<span class="p">}</span>

<span class="c1">//API call-backs for the motion engine configuration data
</span><span class="n">MotionEngine_CallBack_CFG_t</span> <span class="n">g_MotionEngine_CallBackCfg</span> <span class="o">=</span> <span class="p">{</span>
        <span class="nb">NULL</span><span class="p">,</span> <span class="c1">//motion status
</span>        <span class="nb">NULL</span><span class="p">,</span> <span class="c1">//6-axis IMU data - accelerometer and gyroscope
</span>        <span class="nb">NULL</span><span class="p">,</span> <span class="c1">//Quaternion
</span>        <span class="nb">NULL</span><span class="p">,</span> <span class="c1">//Euler Angles
</span>        <span class="nb">NULL</span><span class="p">,</span> <span class="c1">//External Force
</span>        <span class="nb">NULL</span><span class="p">,</span> <span class="c1">//Euler Angle Error
</span>        <span class="n">PedometerCallBackFunction</span><span class="p">,</span> <span class="c1">//Pedometer
</span>        <span class="nb">NULL</span><span class="p">,</span> <span class="c1">//Magnetometer data
</span>        <span class="nb">NULL</span><span class="p">,</span> <span class="c1">//Sitting/Standing Report
</span><span class="p">};</span>
</code></pre>

<h2 id="update-motion-features-main-api-function">Update Motion Features Main API Function</h2>

<p><code class="prettyprint">
Host_RcvdPacket_UpdateMotionFeatures(uint8_t* buf, Motion_Feature_t* dev, MotionEngine_CallBack_CFG_t cfg)
</code></p>

<blockquote>
<p>The motion features list has the following data structure:</p>
</blockquote>
<pre class="highlight c"><code><span class="k">typedef</span> <span class="k">struct</span> <span class="n">Motion_Feature_t</span><span class="p">{</span> <span class="c1">//all features
</span>    <span class="kt">uint8_t</span> <span class="n">motion</span><span class="p">;</span> <span class="c1">//0: no change in motion, 1: stops moving, 2: starts moving
</span>    <span class="n">IMURaw_t</span> <span class="n">IMUData</span><span class="p">;</span>
    <span class="n">Quaternion_t</span> <span class="n">quatrn</span><span class="p">;</span>
    <span class="n">Euler_fxp_t</span> <span class="n">angles</span><span class="p">;</span>
    <span class="n">Fext_Vec16_t</span> <span class="n">force</span><span class="p">;</span>
    <span class="n">Euler_fxp_t</span> <span class="n">angles_err</span><span class="p">;</span> <span class="c1">//error in Euler angles compared to a reference trajectory
</span>    <span class="kt">uint16_t</span> <span class="n">motiontrack_cntr</span><span class="p">;</span> <span class="c1">//shows how many times the pre-recorded track has been repeated
</span>    <span class="kt">uint8_t</span> <span class="n">motiontrack_progress</span><span class="p">;</span> <span class="c1">//the percentage showing how much of a pre-recorded track has been covered
</span>    <span class="kt">uint32_t</span> <span class="n">TimeStamp</span><span class="p">;</span> <span class="c1">//in microseconds
</span>    <span class="n">steps_t</span> <span class="n">steps</span><span class="p">;</span>
    <span class="kt">int16_t</span> <span class="n">direction</span><span class="p">;</span>
<span class="p">}</span> <span class="n">Motion_Feature_t</span><span class="p">;</span>
</code></pre>

<p>This is an important function that should be called every time a new BLE packet <code class="prettyprint">buf</code> targeting the motion engine is received by the host.</p>

<p>This function will essentially update one or more features from the motion features list including motion status, 9-axis raw data, quaternion, Euler angles, external force, Euler angle errors, Pedometer, etc.</p>

<p>The <code class="prettyprint">cfg</code> argument defines all the user-defined API call back functions for specific motion features.</p>

          <h1 id="neblina-data-format">Neblina - Data Format</h1>

<h2 id="general-format">General Format</h2>

<h3 id="nomenclature-byte-ordering-bit-ordering">Nomenclature, byte ordering, bit ordering</h3>

<p>The Neblina platform is meant to be network-centric.  To support this concept globally and allow the packets to be transported over various mediums a lightweight stack was defined.  </p>

<p>The transport medium for the packets could be UDP, TCP, Bluetooth LE Characteristic (main focus of this project), Serial Interface, light pulses or electrical pulses.  The protocol is meant to be as stateless as possible.</p>

<p>The general format of the packets being transferred between Neblina and the host application is as follows:</p>

<table><thead>
<tr>
<th>Bytes 0-3</th>
<th>Bytes 4-255 (currently limited to 4-19)</th>
</tr>
</thead><tbody>
<tr>
<td>Header Section</td>
<td>Data Section (16 bytes in this API)</td>
</tr>
</tbody></table>

<p><strong>Limitation</strong>: At this time, the Data Section spans bytes 4-19 (complete packet is maxed at 20 bytes).  The protocol supports larger packets, but for the best use of the BLE MTU, a special effort is made to ensure that no packet exceed 20 bytes.  This allows more efficient transfer of real-time characteristic updates when streaming motion data.</p>

<p>The <strong>Header Section</strong> is used to route the commands from the application (e.g. an iPhone) to the Neblina module and identify the responses back from Neblina and destined for the application.</p>

<p>Based on the <strong>Header Section</strong> a command will be directed to the appropriate subsystem which can be the radio IC of the Neblina or the motion processor.  In other systems, some commands may be passed on to peripheral devices, so the protocol allows for scalability.  The <strong>Data Section</strong> will vary depending on the subsystem interpreting the command.</p>

<p>For example, commands destined to the Motion Engine subsystem will have a header with 0x01 in the subsystem value.</p>

<h3 id="header-section">Header Section</h3>

<p>The header section consists of four bytes.</p>

<table><thead>
<tr>
<th>Byte 0</th>
<th>Byte 1</th>
<th>Byte 2</th>
<th>Byte 3</th>
</tr>
</thead><tbody>
<tr>
<td><strong>Control Byte (PKT_TYPE/SUB)</strong></td>
<td>data length</td>
<td>CRC</td>
<td>Command Type</td>
</tr>
</tbody></table>

<p>Control Byte Details</p>

<table><thead>
<tr>
<th style="text-align: center">Bit 7:5 (PKT_TYPE)</th>
<th style="text-align: center">Bit 4:0 (SUB)</th>
</tr>
</thead><tbody>
<tr>
<td style="text-align: center">Packet Type</td>
<td style="text-align: center">Subsystem Code</td>
</tr>
</tbody></table>

<h4 id="byte-0-control-byte">Byte 0: Control Byte</h4>
<pre class="highlight c"><code><span class="n">Bit</span><span class="err">#</span><span class="mi">7</span><span class="o">-</span><span class="mi">5</span><span class="o">:</span> <span class="p">(</span><span class="n">PKT_TYPE</span><span class="p">)</span> <span class="n">Packet</span> <span class="n">Type</span> 
</code></pre>

<p>This field generally determines the type of the packet. Currently, the types include: regular command/response packets, error log command/response packets, and an acknowledge response packet from Neblina to a command issued by the host. The 8 possible combinations of the packet type field are described below:</p>

<table><thead>
<tr>
<th style="text-align: center">Bit 7:5 (PKT_TYPE)</th>
<th>Description</th>
</tr>
</thead><tbody>
<tr>
<td style="text-align: center">000</td>
<td>Regular response packet from Neblina with data</td>
</tr>
<tr>
<td style="text-align: center">001</td>
<td>Acknowledge from Neblina to a command from the host</td>
</tr>
<tr>
<td style="text-align: center">010</td>
<td>Regular command packet from the host</td>
</tr>
<tr>
<td style="text-align: center">011</td>
<td>Reserved</td>
</tr>
<tr>
<td style="text-align: center">100</td>
<td>Error log response from Neblina</td>
</tr>
<tr>
<td style="text-align: center">101</td>
<td>Reserved</td>
</tr>
<tr>
<td style="text-align: center">110</td>
<td>Error log command from the host</td>
</tr>
<tr>
<td style="text-align: center">111</td>
<td>Reserved</td>
</tr>
</tbody></table>

<p>Note that the above packet types are all associated with the subsystem represented by the <em>SUB</em> field. </p>

<!---
```c 
Bit#7: (ERR) Error Log Indicator
```
If set to 1, it shows that the packet is an error log command/response associated with the subsystem represented by *SUB*. Otherwise, if set to 0, it shows that the packet is a regular command/response associated with the subsystem represented by *SUB*.

```c 
Bit#6: (CR) Command/Response Indicator
```
If set to 1, it shows that the packet is a command from the host to the target device. Otherwise, the packet is a response from the target to the host. *Note: Target is usually the Neblina module or one of its component, host is a tablet or smartphone*

```c 
Bit#5: (ACK) Acknowledge Indicator
```
If set to 1, it shows that the packet is a simple acknowledge response from Neblina to a command issued by the host.
--->
<pre class="highlight c"><code><span class="n">Bits</span><span class="err">#</span><span class="mi">4</span><span class="o">-</span><span class="mi">0</span><span class="o">:</span> <span class="p">(</span><span class="n">SUB</span><span class="p">)</span> <span class="n">Subsystem</span> <span class="n">Identifier</span>
</code></pre>

<p>This is the subsystem identifier:</p>

<ol>
<li><strong>0x00 <a href="_debug.md">Debug Subsystem</a></strong>: Information about the device, special modes, etc.</li>
<li><strong>0x01 <a href="_motionenginepackets.md">Motion Engine</a></strong>: Motion data information, orientation, quaternions, trajectories, acceleration, magnetic, etc.</li>
<li><strong>0x02 <a href="_powermanagement.md">Power Management</a></strong>: Battery information, voltages and other information related to the power management IC</li>
<li><strong>0x03 <a href="_digitalio.md">Digital IO</a></strong>: Digital IO on the module</li>
<li><strong>0x04 <a href="_led.md">LEDs or indicators</a></strong>: LEDs (unicolor or RGB, backlights)</li>
<li><strong>0x05 <a href="_adc.md">Analog to Digital Converters (ADC)</a></strong>: Access to module ADCs</li>
<li><strong>0x06 <a href="_dac.md">Digital to Analog Converters (DAC)</a></strong>: Access to module DACs</li>
<li><strong>0x07 <a href="_i2c.md">I2C Subsystem</a></strong>: Access to I2C subsystems (for programmers)</li>
<li><strong>0x08 <a href="_spi.md">SPI Subsystem</a></strong>: Access to SPI subsystems (for programmers)</li>
<li><strong>0x09 <a href="_firmware.md">Firmware Management</a></strong>: Firmware versions, firmware checks, self-test, serial numbers</li>
<li><strong>0x0A <a href="_security.md">Cryptography</a></strong>: Cryptography peripherals, data security</li>
<li><strong>0x0B <a href="_norflash.md">Storage</a></strong>: NOR Flash Recorder: recording several hours of streaming data</li>
<li><strong>0x0C <a href="_eeprom.md">EEPROM</a></strong>: EEPROM Read/Write: board ID, features, etc. </li>
</ol>

<h4 id="byte-1-data-section-packet-length">Byte 1: Data Section Packet Length</h4>

<p>In this version of the API, the data format currently is set to a fixed packet length of 20 bytes (including both header and data), where the data section is 16 bytes. Hence, this byte is set to the value of 0x10 = 16.  Bytes that are not used by subsystems commands and responses should be padded with zeros when the packets are created.  When packet are interpreted, no assumptions should be made on the content of the packet outside of their defined bytes fields.</p>

<p>Note that this fixed length attribute of the packets may change in future APIs.</p>

<h4 id="byte-2-crc">Byte 2: CRC</h4>

<p>The 8-bit CRC is calculated over both the header and data sections of the packet. The polynomial is initialized to 0x00.  </p>
<pre class="highlight plaintext"><code>crc = 0;
for (i = 0; i &lt; Len; i++)
{
    e = crc ^ pData[i];
    f = e ^ (e &gt;&gt; 4) ^ (e &gt;&gt; 7);
    crc = (f &lt;&lt; 1) ^ (f &lt;&lt; 4);
}
</code></pre>

<p>The calculations are done as follows:</p>

<p>To create the packet, the CRC byte is set to 0xFF.  Then the CRC computation is performed on the complete packet (based on the length information), including the header. The CRC byte is then replaced with the computed value.</p>

<p>To validate the CRC, the code first takes a copy of the CRC byte then sets it to 0xFF.  It calculates the CRC as for transmission and then compares the calculated CRC against the copied data.</p>

<h4 id="byte-3-command">Byte 3: Command</h4>

<p>Commands are defined per subsystem.  Refer to the appropriate section of the documentation for command details.</p>

<hr>

<p>Different commands can be issued identified by this field. For the power management subsystem, currently there is only one command as follows:
&ldquo;`c </p>

<h1 id="define-powermgmt_get_bat_level-0">define POWERMGMT_GET_BAT_LEVEL 0</h1>
<pre class="highlight plaintext"><code>There is also a single command corresponding to the Debug mode, that is to set the interface protocol between the host and Neblina. By default, the interface is set to BLE, but we can set the interface to UART as well. Here is the command code for setting the interface:
```c 
#define DEBUG_SET_INTERFACE 1
</code></pre>

          <h1 id="power-management-api-0x02">Power Management API (0x02)</h1>

<h2 id="get-battery-level-state-of-charge">Get Battery Level (State of Charge)</h2>
<pre class="highlight c"><code><span class="n">GET_BAT_LEVEL</span> <span class="mh">0x00</span>
</code></pre>

<table><thead>
<tr>
<th style="text-align: center">HEADER(0-3)</th>
<th style="text-align: center">Command</th>
<th style="text-align: center">Bit 0</th>
</tr>
</thead><tbody>
<tr>
<td style="text-align: center">Reserved</td>
<td style="text-align: center">Mode[1:0]</td>
<td style="text-align: center">Direction</td>
</tr>
</tbody></table>

<p>Note: When requested over BLE, this command will not get a response out of the Neblina Custom Characteristic.  Bluetooth standardizes the battery information.  To get the battery level via BLE, simply read it from the standard org.bluetooth.characteristic.battery_level characteristic (0x2A19).</p>

<p>This command is usually used internally within Neblina between the application processor and the radio IC.  It would therefore only apply for advanced users who want to program inside the Neblina module.</p>

<p>Regarding the power management&rsquo;s single command, the data consists of only 2 valid bytes (Byte#8-9), representing the percentage of the battery level with one decimal fractional digit precision, i.e., an unsigned integer within the range of [0, 1000]:
Byte#8: battery level (%), Least Significant Byte (LSB)
Byte#9: battery level (%), Most Significant Byte (MSB)</p>

      </div>
      <div class="dark-box">
          <div class="lang-selector">
                <a href="#" data-language-name="C">C code</a>
                <a href="#" data-language-name="swift">Swift</a>
                <a href="#" data-language-name="java">Java</a>
          </div>
      </div>
    </div>
  </body>
</html>
